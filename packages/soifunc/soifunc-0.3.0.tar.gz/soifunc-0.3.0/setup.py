# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['soifunc']

package_data = \
{'': ['*']}

install_requires = \
['vapoursynth>=60', 'vsdeband>=0.7.2', 'vsutil>=0.8.0,<0.9.0']

setup_kwargs = {
    'name': 'soifunc',
    'version': '0.3.0',
    'description': "Soichiro's VapourSynth Functions Collection",
    'long_description': '## soifunc\n\nVapoursynth scripts that might be useful to someone\n\n### Installation\n\n#### Arch Linux\n\nInstall from [AUR](https://aur.archlinux.org/packages/vapoursynth-plugin-soifunc-git)\n\n#### Other\n\nFirst install the required plugins which are not available in pip:\n\n- [neo_f3kdb](https://github.com/HomeOfAviSynthPlusEvolution/neo_f3kdb)\n- [kagefunc](https://github.com/Irrational-Encoding-Wizardry/kagefunc)\n- [muvsfunc](https://github.com/WolframRhodium/muvsfunc)\n- [havsfunc](https://github.com/WolframRhodium/havsfunc)\n- [mvsfunc](https://github.com/HomeOfVapourSynthEvolution/mvsfunc)\n- [znedi3](https://github.com/sekrit-twc/znedi3)\n- [nnedi3_resample](https://github.com/HomeOfVapourSynthEvolution/nnedi3_resample)\n- [BM3DCUDA](https://github.com/WolframRhodium/VapourSynth-BM3DCUDA)\n\nInstall from pip:\n\n```bash\npip install soifunc\n```\n\nOr the latest git version:\n\n```bash\npip install git+https://github.com/shssoichiro/soifunc.git\n```\n\n### Usage\n\nAny of the functions will require an `import soifunc` prior to where they are used.\n\n#### GoodResize\n\n`clip = soifunc.GoodResize(clip, 1920, 1080)`\n\nResizes a clip to the specified dimensions using a high quality method.\n\nFor upscaling, luma is resized using `nnedi3_resample`.\n\nFor downscaling, luma is resized using `SSIM_downsample`.\n\nChroma is always resized using `Spline36`.\n\n**If this filter causes your video to produce a blank output**, see this issue: https://github.com/HomeOfVapourSynthEvolution/VapourSynth-TCanny/issues/14\n\nAdditional Params:\n\n- `gpu`: Whether to use the OpenCL version of supported dependencies (currently applies to upscaling).\n- `device`: Sets target OpenCL device.\n\n#### RetinexDeband\n\n`clip = soifunc.RetinexDeband(clip, threshold = 16 [, showmask = False])`\n\nHigh quality debanding using a retinex mask, designed to preserve details in both light and dark areas.\n\n`threshold` controls debanding strength. `16` is a reasonable starting point. Increase as needed until satisfied.\n\n`showmask` is an optional debugging parameter, setting this to `True` will output the mask that will be used to preserve edges.\n\nNote that this debander does not automatically add grain.\nIf you need to add grain before encoding, use `kagefunc.adaptive_grain`.\nIf you\'re using AV1 grain synthesis, you _do not_ need to add grain before encoding.\n\n#### ClipLimited\n\n`clip = soifunc.ClipLimited(clip)`\n\nCompression introduces rounding errors and whatnot that can lead\nto some pixels in your source being outside the range of\nvalid Limited range values. These are clamped to the valid\nrange by the player on playback, but that means we can save\na small amount of bitrate if we clamp them at encode time.\nThis function does that.\n\nRecommended to use at the very end of your filter chain,\nin the final encode bit depth.\n\n#### BM3DCUDA Wrappers\n\nSee [BM3DCUDA](https://github.com/WolframRhodium/VapourSynth-BM3DCUDA) for list of args.\n\n`clip = soifunc.BM3DCPU(clip, ...args)`\n\n`clip = soifunc.BM3DCuda(clip, ...args)`\n\n`clip = soifunc.BM3DCuda_RTC(clip, ...args)`\n\nProvides wrappers around the accelerated BM3D functions in BM3DCUDA, similar to the wrapper provided for the base BM3D plugin in mvsfunc.\nThese functions perform all necessary colorspace conversion, so they are considerably simpler to use than manually calling BM3DCuda.\n\n#### MCDenoise\n\nApplies motion compensation to a denoised clip to improve detail preservation.\nCredit to Clybius for creating this code.\n\nExample usage:\n\n```python\nimport soifunc\nimport dfttest2\nimport functools    # functools is built in to python\ndenoiser = functools.partial(dfttest2.DFTTest, sigma=1.5, backend=dfttest2.Backend.CPU)\nclip = soifunc.MCDenoise(clip, denoiser)\n```\n\nParams:\n\n- `denoiser`: A function defining how to denoise the motion-compensated frames.\n  Denoiser params can be added using `functools.partial`.\n- `prefilter`: An optional prefiltered input clip to enable better searching for motion vectors\n\n#### SQTGMC\n\nThis is a modification of the QTGMC function from havsfunc, but simplified.\nQTGMC has 90 args and this causes both its usability and maintainability to suffer.\nThis version removes a majority of parameters, either baking them into a preset,\nauto-detecting them based on the video source, or removing their functionality entirely.\n\nThe presets are also simplified into "slowest", "slow", "medium", "fast", and "fastest",\nand match/noise presets are no longer separate from the primary preset.\n\nParams:\n\n- `clip`: The input video to apply deinterlacing to\n- `preset`: Speed/quality tradeoff. One of "slowest", "slow", "medium", "fast", and "fastest"\n  Default: "slow"\n- `input_type`: Default = 0 for interlaced input.\n  Settings 1 & 2 accept progressive input for deshimmer or repair.\n  Frame rate of progressive source is not doubled.\n  Mode 1 is for general progressive material.\n  Mode 2 is designed for badly deinterlaced material.\n- `tff`: Since VapourSynth only has a weak notion of field order internally,\n  `tff` may have to be set. Setting `tff` to `True` means top field first\n  and `False` means bottom field first. Note that the `_FieldBased` frame property,\n  if present, takes precedence over `tff`.\n- `fps_divisor`: 1 = Double-rate output, 2 = Single-rate output.\n  Higher values can be used too (e.g. 60 fps & `fps_divisor=3` gives 20 fps output).\n- `prog_sad_mask`: Only applies to `input_type=2`.\n  If `prog_sad_mask` > 0.0 then blend `input_type` modes 1 and 2 based on block motion SAD.\n  Higher values help recover more detail, but repair fewer artifacts.\n  Reasonable range about 2.0 to 20.0, or 0.0 for no blending.\n- `sigma`: Amount of noise known to be in the source,\n  sensible values vary by source and denoiser, so experiment.\n  Use `show_noise` to help.\n- `show_noise`: Display extracted and "deinterlaced" noise rather than normal output.\n  Set to `True` or `False`, or set a value (around 4 to 16) to specify\n  contrast for displayed noise. Visualising noise helps to determine suitable value\n  for `sigma` - want to see noise and noisy detail,\n  but not too much clean structure or edges - fairly subjective.\n- `grain_restore`: How much removed grain to restore before final temporal smooth.\n  Retain "stable" grain and some detail.\n- `noise_restore`: How much removed noise to restore after final temporal smooth.\n  Retains any kind of noise.\n- `border`: Pad a little vertically while processing (doesn\'t affect output size).\n  Set `True` you see flickering on the very top or bottom line of the\n  output. If you have wider edge effects than that, you should crop afterwards instead.\n- `gpu`: Whether to use the OpenCL version of supported dependencies.\n- `device`: Sets target OpenCL device.\n\n#### MagicDenoise\n\nClybius\'s magic denoise function.\n\nUses dark magic to denoise heavy grain from videos.\nZero parameters, only magic.\n\nParams:\n\n- `clip`: The input video to apply deinterlacing to\n- `gpu`: Whether to use the OpenCL version of supported dependencies.\n',
    'author': 'Josh Holmer',
    'author_email': 'jholmer.in@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
