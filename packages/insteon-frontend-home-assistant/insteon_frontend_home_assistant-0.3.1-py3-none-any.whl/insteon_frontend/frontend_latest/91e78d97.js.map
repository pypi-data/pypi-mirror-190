{"version":3,"file":"91e78d97.js","mappings":";AAsCA;;AAEA;;;AAmRA;AACA;;;;AAIA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;;;AArBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;;;;AAIA;AACA;AACA;;;;;AAKA;;;AAIA;;;AAGA;AACA;;;;AAKA;AACA;;AAEA;AACA;;;AAnIA;AA6IA;AA7IA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;AC5DA","sources":["webpack://insteon-panel-frontend/./homeassistant-frontend/src/components/ha-area-picker.ts","webpack://insteon-panel-frontend/./homeassistant-frontend/src/components/ha-combo-box.ts","webpack://insteon-panel-frontend/./homeassistant-frontend/src/components/ha-switch.ts"],"sourcesContent":["import { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport {\n  AreaRegistryEntry,\n  createAreaRegistryEntry,\n  subscribeAreaRegistry,\n} from \"../data/area_registry\";\nimport {\n  DeviceEntityLookup,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../data/entity_registry\";\nimport {\n  showAlertDialog,\n  showPromptDialog,\n} from \"../dialogs/generic/show-dialog-box\";\nimport { SubscribeMixin } from \"../mixins/subscribe-mixin\";\nimport { PolymerChangedEvent } from \"../polymer-types\";\nimport { HomeAssistant } from \"../types\";\nimport type { HaDevicePickerDeviceFilterFunc } from \"./device/ha-device-picker\";\nimport \"./ha-combo-box\";\nimport type { HaComboBox } from \"./ha-combo-box\";\nimport \"./ha-icon-button\";\nimport \"./ha-svg-icon\";\n\nconst rowRenderer: ComboBoxLitRenderer<AreaRegistryEntry> = (\n  item\n) => html`<mwc-list-item\n  class=${classMap({ \"add-new\": item.area_id === \"add_new\" })}\n>\n  ${item.name}\n</mwc-list-item>`;\n\n@customElement(\"ha-area-picker\")\nexport class HaAreaPicker extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property() public placeholder?: string;\n\n  @property({ type: Boolean, attribute: \"no-add\" })\n  public noAdd?: boolean;\n\n  /**\n   * Show only areas with entities from specific domains.\n   * @type {Array}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no areas with entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only areas with entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  @property() public deviceFilter?: HaDevicePickerDeviceFilterFunc;\n\n  @property() public entityFilter?: (entity: EntityRegistryEntry) => boolean;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @state() private _areas?: AreaRegistryEntry[];\n\n  @state() private _devices?: DeviceRegistryEntry[];\n\n  @state() private _entities?: EntityRegistryEntry[];\n\n  @state() private _opened?: boolean;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  private _filter?: string;\n\n  private _init = false;\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeAreaRegistry(this.hass.connection!, (areas) => {\n        this._areas = areas;\n      }),\n      subscribeDeviceRegistry(this.hass.connection!, (devices) => {\n        this._devices = devices;\n      }),\n      subscribeEntityRegistry(this.hass.connection!, (entities) => {\n        this._entities = entities;\n      }),\n    ];\n  }\n\n  public open() {\n    this.updateComplete.then(() => {\n      this.comboBox?.open();\n    });\n  }\n\n  public focus() {\n    this.updateComplete.then(() => {\n      this.comboBox?.focus();\n    });\n  }\n\n  private _getAreas = memoizeOne(\n    (\n      areas: AreaRegistryEntry[],\n      devices: DeviceRegistryEntry[],\n      entities: EntityRegistryEntry[],\n      includeDomains: this[\"includeDomains\"],\n      excludeDomains: this[\"excludeDomains\"],\n      includeDeviceClasses: this[\"includeDeviceClasses\"],\n      deviceFilter: this[\"deviceFilter\"],\n      entityFilter: this[\"entityFilter\"],\n      noAdd: this[\"noAdd\"]\n    ): AreaRegistryEntry[] => {\n      if (!areas.length) {\n        return [\n          {\n            area_id: \"no_areas\",\n            name: this.hass.localize(\"ui.components.area-picker.no_areas\"),\n            picture: null,\n          },\n        ];\n      }\n\n      const deviceEntityLookup: DeviceEntityLookup = {};\n      let inputDevices: DeviceRegistryEntry[] | undefined;\n      let inputEntities: EntityRegistryEntry[] | undefined;\n\n      if (includeDomains || excludeDomains || includeDeviceClasses) {\n        for (const entity of entities) {\n          if (!entity.device_id) {\n            continue;\n          }\n          if (!(entity.device_id in deviceEntityLookup)) {\n            deviceEntityLookup[entity.device_id] = [];\n          }\n          deviceEntityLookup[entity.device_id].push(entity);\n        }\n        inputDevices = devices;\n        inputEntities = entities.filter((entity) => entity.area_id);\n      } else {\n        if (deviceFilter) {\n          inputDevices = devices;\n        }\n        if (entityFilter) {\n          inputEntities = entities.filter((entity) => entity.area_id);\n        }\n      }\n\n      if (includeDomains) {\n        inputDevices = inputDevices!.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) =>\n            includeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n        inputEntities = inputEntities!.filter((entity) =>\n          includeDomains.includes(computeDomain(entity.entity_id))\n        );\n      }\n\n      if (excludeDomains) {\n        inputDevices = inputDevices!.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return true;\n          }\n          return entities.every(\n            (entity) =>\n              !excludeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n        inputEntities = inputEntities!.filter(\n          (entity) => !excludeDomains.includes(computeDomain(entity.entity_id))\n        );\n      }\n\n      if (includeDeviceClasses) {\n        inputDevices = inputDevices!.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            if (!stateObj) {\n              return false;\n            }\n            return (\n              stateObj.attributes.device_class &&\n              includeDeviceClasses.includes(stateObj.attributes.device_class)\n            );\n          });\n        });\n        inputEntities = inputEntities!.filter((entity) => {\n          const stateObj = this.hass.states[entity.entity_id];\n          return (\n            stateObj.attributes.device_class &&\n            includeDeviceClasses.includes(stateObj.attributes.device_class)\n          );\n        });\n      }\n\n      if (deviceFilter) {\n        inputDevices = inputDevices!.filter((device) => deviceFilter!(device));\n      }\n\n      if (entityFilter) {\n        inputEntities = inputEntities!.filter((entity) =>\n          entityFilter!(entity)\n        );\n      }\n\n      let outputAreas = areas;\n\n      let areaIds: string[] | undefined;\n\n      if (inputDevices) {\n        areaIds = inputDevices\n          .filter((device) => device.area_id)\n          .map((device) => device.area_id!);\n      }\n\n      if (inputEntities) {\n        areaIds = (areaIds ?? []).concat(\n          inputEntities\n            .filter((entity) => entity.area_id)\n            .map((entity) => entity.area_id!)\n        );\n      }\n\n      if (areaIds) {\n        outputAreas = areas.filter((area) => areaIds!.includes(area.area_id));\n      }\n\n      if (!outputAreas.length) {\n        outputAreas = [\n          {\n            area_id: \"no_areas\",\n            name: this.hass.localize(\"ui.components.area-picker.no_match\"),\n            picture: null,\n          },\n        ];\n      }\n\n      return noAdd\n        ? outputAreas\n        : [\n            ...outputAreas,\n            {\n              area_id: \"add_new\",\n              name: this.hass.localize(\"ui.components.area-picker.add_new\"),\n              picture: null,\n            },\n          ];\n    }\n  );\n\n  protected updated(changedProps: PropertyValues) {\n    if (\n      (!this._init && this._devices && this._areas && this._entities) ||\n      (changedProps.has(\"_opened\") && this._opened)\n    ) {\n      this._init = true;\n      (this.comboBox as any).items = this._getAreas(\n        this._areas!,\n        this._devices!,\n        this._entities!,\n        this.includeDomains,\n        this.excludeDomains,\n        this.includeDeviceClasses,\n        this.deviceFilter,\n        this.entityFilter,\n        this.noAdd\n      );\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this._devices || !this._areas || !this._entities) {\n      return html``;\n    }\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .helper=${this.helper}\n        item-value-path=\"area_id\"\n        item-id-path=\"area_id\"\n        item-label-path=\"name\"\n        .value=${this.value}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        .label=${this.label === undefined && this.hass\n          ? this.hass.localize(\"ui.components.area-picker.area\")\n          : this.label}\n        .placeholder=${this.placeholder\n          ? this._area(this.placeholder)?.name\n          : undefined}\n        .renderer=${rowRenderer}\n        @filter-changed=${this._filterChanged}\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._areaChanged}\n      >\n      </ha-combo-box>\n    `;\n  }\n\n  private _area = memoizeOne((areaId: string): AreaRegistryEntry | undefined =>\n    this._areas?.find((area) => area.area_id === areaId)\n  );\n\n  private _filterChanged(ev: CustomEvent): void {\n    this._filter = ev.detail.value;\n    if (!this._filter) {\n      this.comboBox.filteredItems = this.comboBox.items;\n      return;\n    }\n    // @ts-ignore\n    if (!this.noAdd && this.comboBox._comboBox.filteredItems?.length === 0) {\n      this.comboBox.filteredItems = [\n        {\n          area_id: \"add_new_suggestion\",\n          name: this.hass.localize(\n            \"ui.components.area-picker.add_new_sugestion\",\n            { name: this._filter }\n          ),\n          picture: null,\n        },\n      ];\n    } else {\n      this.comboBox.filteredItems = this.comboBox.items?.filter((item) =>\n        item.name.toLowerCase().includes(this._filter!.toLowerCase())\n      );\n    }\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _areaChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    let newValue = ev.detail.value;\n\n    if (newValue === \"no_areas\") {\n      newValue = \"\";\n    }\n\n    if (![\"add_new_suggestion\", \"add_new\"].includes(newValue)) {\n      if (newValue !== this._value) {\n        this._setValue(newValue);\n      }\n      return;\n    }\n\n    (ev.target as any).value = this._value;\n    showPromptDialog(this, {\n      title: this.hass.localize(\"ui.components.area-picker.add_dialog.title\"),\n      text: this.hass.localize(\"ui.components.area-picker.add_dialog.text\"),\n      confirmText: this.hass.localize(\n        \"ui.components.area-picker.add_dialog.add\"\n      ),\n      inputLabel: this.hass.localize(\n        \"ui.components.area-picker.add_dialog.name\"\n      ),\n      defaultValue:\n        newValue === \"add_new_suggestion\" ? this._filter : undefined,\n      confirm: async (name) => {\n        if (!name) {\n          return;\n        }\n        try {\n          const area = await createAreaRegistryEntry(this.hass, {\n            name,\n          });\n          this._areas = [...this._areas!, area];\n          (this.comboBox as any).filteredItems = this._getAreas(\n            this._areas!,\n            this._devices!,\n            this._entities!,\n            this.includeDomains,\n            this.excludeDomains,\n            this.includeDeviceClasses,\n            this.deviceFilter,\n            this.entityFilter,\n            this.noAdd\n          );\n          await this.updateComplete;\n          await this.comboBox.updateComplete;\n          this._setValue(area.area_id);\n        } catch (err: any) {\n          showAlertDialog(this, {\n            title: this.hass.localize(\n              \"ui.components.area-picker.add_dialog.failed_create_area\"\n            ),\n            text: err.message,\n          });\n        }\n      },\n    });\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-area-picker\": HaAreaPicker;\n  }\n}\n","import \"@material/mwc-list/mwc-list-item\";\nimport { mdiClose, mdiMenuDown, mdiMenuUp } from \"@mdi/js\";\nimport \"@vaadin/combo-box/theme/material/vaadin-combo-box-light\";\nimport type {\n  ComboBoxLight,\n  ComboBoxLightFilterChangedEvent,\n  ComboBoxLightOpenedChangedEvent,\n  ComboBoxLightValueChangedEvent,\n} from \"@vaadin/combo-box/vaadin-combo-box-light\";\nimport { registerStyles } from \"@vaadin/vaadin-themable-mixin/register-styles\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { ComboBoxLitRenderer, comboBoxRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { HomeAssistant } from \"../types\";\nimport \"./ha-icon-button\";\nimport \"./ha-textfield\";\n\nregisterStyles(\n  \"vaadin-combo-box-item\",\n  css`\n    :host {\n      padding: 0;\n    }\n    :host([focused]:not([disabled])) {\n      background-color: rgba(var(--rgb-primary-text-color, 0, 0, 0), 0.12);\n    }\n    :host([selected]:not([disabled])) {\n      background-color: transparent;\n      color: var(--mdc-theme-primary);\n      --mdc-ripple-color: var(--mdc-theme-primary);\n      --mdc-theme-text-primary-on-background: var(--mdc-theme-primary);\n    }\n    :host([selected]:not([disabled])):before {\n      background-color: var(--mdc-theme-primary);\n      opacity: 0.12;\n      content: \"\";\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n    }\n    :host([selected][focused]:not([disabled])):before {\n      opacity: 0.24;\n    }\n    :host(:hover:not([disabled])) {\n      background-color: transparent;\n    }\n    [part=\"content\"] {\n      width: 100%;\n    }\n    [part=\"checkmark\"] {\n      display: none;\n    }\n  `\n);\n\n@customElement(\"ha-combo-box\")\nexport class HaComboBox extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public placeholder?: string;\n\n  @property() public validationMessage?: string;\n\n  @property() public helper?: string;\n\n  @property({ attribute: \"error-message\" }) public errorMessage?: string;\n\n  @property({ type: Boolean }) public invalid = false;\n\n  @property({ type: Boolean }) public icon = false;\n\n  @property({ attribute: false }) public items?: any[];\n\n  @property({ attribute: false }) public filteredItems?: any[];\n\n  @property({ attribute: \"allow-custom-value\", type: Boolean })\n  public allowCustomValue = false;\n\n  @property({ attribute: \"item-value-path\" }) public itemValuePath = \"value\";\n\n  @property({ attribute: \"item-label-path\" }) public itemLabelPath = \"label\";\n\n  @property({ attribute: \"item-id-path\" }) public itemIdPath?: string;\n\n  @property() public renderer?: ComboBoxLitRenderer<any>;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = false;\n\n  @property({ type: Boolean, reflect: true, attribute: \"opened\" })\n  public opened?: boolean;\n\n  @query(\"vaadin-combo-box-light\", true) private _comboBox!: ComboBoxLight;\n\n  private _overlayMutationObserver?: MutationObserver;\n\n  public open() {\n    this.updateComplete.then(() => {\n      this._comboBox?.open();\n    });\n  }\n\n  public focus() {\n    this.updateComplete.then(() => {\n      this._comboBox?.inputElement?.focus();\n    });\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this._overlayMutationObserver) {\n      this._overlayMutationObserver.disconnect();\n      this._overlayMutationObserver = undefined;\n    }\n  }\n\n  public get selectedItem() {\n    return this._comboBox.selectedItem;\n  }\n\n  public setInputValue(value: string) {\n    this._comboBox.value = value;\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <vaadin-combo-box-light\n        .itemValuePath=${this.itemValuePath}\n        .itemIdPath=${this.itemIdPath}\n        .itemLabelPath=${this.itemLabelPath}\n        .items=${this.items}\n        .value=${this.value || \"\"}\n        .filteredItems=${this.filteredItems}\n        .allowCustomValue=${this.allowCustomValue}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        ${comboBoxRenderer(this.renderer || this._defaultRowRenderer)}\n        @opened-changed=${this._openedChanged}\n        @filter-changed=${this._filterChanged}\n        @value-changed=${this._valueChanged}\n        attr-for-value=\"value\"\n      >\n        <ha-textfield\n          label=${ifDefined(this.label)}\n          placeholder=${ifDefined(this.placeholder)}\n          ?disabled=${this.disabled}\n          ?required=${this.required}\n          validationMessage=${ifDefined(this.validationMessage)}\n          .errorMessage=${this.errorMessage}\n          class=\"input\"\n          autocapitalize=\"none\"\n          autocomplete=\"off\"\n          autocorrect=\"off\"\n          spellcheck=\"false\"\n          .suffix=${html`<div\n            style=\"width: 28px;\"\n            role=\"none presentation\"\n          ></div>`}\n          .icon=${this.icon}\n          .invalid=${this.invalid}\n          helper=${ifDefined(this.helper)}\n          helperPersistent\n        >\n          <slot name=\"icon\" slot=\"leadingIcon\"></slot>\n        </ha-textfield>\n        ${this.value\n          ? html`<ha-svg-icon\n              role=\"button\"\n              tabindex=\"-1\"\n              aria-label=${ifDefined(this.hass?.localize(\"ui.common.clear\"))}\n              class=\"clear-button\"\n              .path=${mdiClose}\n              @click=${this._clearValue}\n            ></ha-svg-icon>`\n          : \"\"}\n        <ha-svg-icon\n          role=\"button\"\n          tabindex=\"-1\"\n          aria-label=${ifDefined(this.label)}\n          aria-expanded=${this.opened ? \"true\" : \"false\"}\n          class=\"toggle-button\"\n          .path=${this.opened ? mdiMenuUp : mdiMenuDown}\n          @click=${this._toggleOpen}\n        ></ha-svg-icon>\n      </vaadin-combo-box-light>\n    `;\n  }\n\n  private _defaultRowRenderer: ComboBoxLitRenderer<\n    string | Record<string, any>\n  > = (item) =>\n    html`<mwc-list-item>\n      ${this.itemLabelPath ? item[this.itemLabelPath] : item}\n    </mwc-list-item>`;\n\n  private _clearValue(ev: Event) {\n    ev.stopPropagation();\n    fireEvent(this, \"value-changed\", { value: undefined });\n  }\n\n  private _toggleOpen(ev: Event) {\n    if (this.opened) {\n      this._comboBox?.close();\n      ev.stopPropagation();\n    } else {\n      this._comboBox?.inputElement.focus();\n    }\n  }\n\n  private _openedChanged(ev: ComboBoxLightOpenedChangedEvent) {\n    const opened = ev.detail.value;\n    // delay this so we can handle click event before setting _opened\n    setTimeout(() => {\n      this.opened = opened;\n    }, 0);\n    // @ts-ignore\n    fireEvent(this, ev.type, ev.detail);\n\n    if (opened) {\n      this.removeInertOnOverlay();\n    }\n  }\n\n  private removeInertOnOverlay() {\n    if (\"MutationObserver\" in window && !this._overlayMutationObserver) {\n      const overlay = document.querySelector<HTMLElement>(\n        \"vaadin-combo-box-overlay\"\n      );\n\n      if (!overlay) {\n        return;\n      }\n\n      this._overlayMutationObserver = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n          if (\n            mutation.type === \"attributes\" &&\n            mutation.attributeName === \"inert\"\n          ) {\n            this._overlayMutationObserver?.disconnect();\n            this._overlayMutationObserver = undefined;\n            // @ts-expect-error\n            overlay.inert = false;\n          } else if (mutation.type === \"childList\") {\n            mutation.removedNodes.forEach((node) => {\n              if (node.nodeName === \"VAADIN-COMBO-BOX-OVERLAY\") {\n                this._overlayMutationObserver?.disconnect();\n                this._overlayMutationObserver = undefined;\n              }\n            });\n          }\n        });\n      });\n\n      this._overlayMutationObserver.observe(overlay, {\n        attributes: true,\n      });\n      this._overlayMutationObserver.observe(document.body, {\n        childList: true,\n      });\n    }\n  }\n\n  updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n    if (\n      changedProps.has(\"filteredItems\") ||\n      (changedProps.has(\"items\") && this.opened)\n    ) {\n      this.removeInertOnOverlay();\n    }\n  }\n\n  private _filterChanged(ev: ComboBoxLightFilterChangedEvent) {\n    // @ts-ignore\n    fireEvent(this, ev.type, ev.detail, { composed: false });\n  }\n\n  private _valueChanged(ev: ComboBoxLightValueChangedEvent) {\n    ev.stopPropagation();\n    const newValue = ev.detail.value;\n\n    if (newValue !== this.value) {\n      fireEvent(this, \"value-changed\", { value: newValue || undefined });\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        width: 100%;\n      }\n      vaadin-combo-box-light {\n        position: relative;\n        --vaadin-combo-box-overlay-max-height: calc(45vh);\n      }\n      ha-textfield {\n        width: 100%;\n      }\n      ha-textfield > ha-icon-button {\n        --mdc-icon-button-size: 24px;\n        padding: 2px;\n        color: var(--secondary-text-color);\n      }\n      ha-svg-icon {\n        color: var(--input-dropdown-icon-color);\n        position: absolute;\n        cursor: pointer;\n      }\n      .toggle-button {\n        right: 12px;\n        top: -10px;\n        inset-inline-start: initial;\n        inset-inline-end: 12px;\n        direction: var(--direction);\n      }\n      :host([opened]) .toggle-button {\n        color: var(--primary-color);\n      }\n      .clear-button {\n        --mdc-icon-size: 20px;\n        top: -7px;\n        right: 36px;\n        inset-inline-start: initial;\n        inset-inline-end: 36px;\n        direction: var(--direction);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-combo-box\": HaComboBox;\n  }\n}\n","import { SwitchBase } from \"@material/mwc-switch/deprecated/mwc-switch-base\";\nimport { styles } from \"@material/mwc-switch/deprecated/mwc-switch.css\";\nimport { css } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { forwardHaptic } from \"../data/haptics\";\n\n@customElement(\"ha-switch\")\nexport class HaSwitch extends SwitchBase {\n  // Generate a haptic vibration.\n  // Only set to true if the new value of the switch is applied right away when toggling.\n  // Do not add haptic when a user is required to press save.\n  @property({ type: Boolean }) public haptic = false;\n\n  protected firstUpdated() {\n    super.firstUpdated();\n    this.addEventListener(\"change\", () => {\n      if (this.haptic) {\n        forwardHaptic(\"light\");\n      }\n    });\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host {\n        --mdc-theme-secondary: var(--switch-checked-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__thumb {\n        background-color: var(--switch-checked-button-color);\n        border-color: var(--switch-checked-button-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__track {\n        background-color: var(--switch-checked-track-color);\n        border-color: var(--switch-checked-track-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__thumb {\n        background-color: var(--switch-unchecked-button-color);\n        border-color: var(--switch-unchecked-button-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__track {\n        background-color: var(--switch-unchecked-track-color);\n        border-color: var(--switch-unchecked-track-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-switch\": HaSwitch;\n  }\n}\n"],"names":[],"sourceRoot":""}