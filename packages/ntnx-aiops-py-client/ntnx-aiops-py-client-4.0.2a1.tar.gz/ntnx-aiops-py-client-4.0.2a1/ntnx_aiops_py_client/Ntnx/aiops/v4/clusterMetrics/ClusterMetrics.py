# coding: utf-8


"""
IGNORE:
    Nutanix Aiops Versioned APIs

    Manage infrastructure on-premises and in the cloud seamlessly through AIOps features such as Analysis, Reporting, Capacity Planning, What if Analysis, VM Rightsizing, Troubleshooting, App Discovery, Broad Observability, and Ops Automation through Playbooks.  # noqa: E501

    OpenAPI spec version: 4.0.2-alpha-1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from ntnx_aiops_py_client.Ntnx.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
from ntnx_aiops_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
from ntnx_aiops_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501

"""
IGNORE:
NOTE: This class is auto generated by the swagger code generator program.

Do not edit the class manually.
IGNORE
"""


class ClusterMetrics(ExternalizableAbstractModel):
    """ClusterMetrics - a model defined in Swagger"""
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """ # noqa: E501
    swagger_types = {
        'cluster_name': 'str',
        'external_ip': 'common.v1.config.IPv4Address',
        'cvm_i_ps': 'list[common.v1.config.IPv4Address]',
        'total_memory_size_bytes': 'int',
        'current_memory_usage_size_bytes': 'int',
        'provisioned_memory_usage_bytes': 'int',
        'max_vm_memory_size_bytes': 'int',
        'available_memory_size_bytes': 'int',
        'largest_powered_off_vm_memory': 'int',
        'total_v_cpu_count': 'int',
        'current_used_v_cpu_count': 'int',
        'provisioned_v_cpu_count': 'int',
        'max_vm_v_cpu_size': 'int',
        'available_v_cpu_count': 'int',
        'largest_powered_off_vmv_cpu': 'int',
        'total_cpu_hz': 'int',
        'current_used_cpu_hz': 'int',
        'provisioned_cpu_hz': 'int',
        'total_storage_capacity_raw_bytes': 'int',
        'total_storage_capacity_logical_bytes': 'int',
        'total_storage_capacity_logical_with_savings_bytes': 'int',
        'total_storage_usage_bytes': 'int',
        'total_storage_available_bytes': 'int',
        'total_storage_available_logical_bytes': 'int',
        'ext_id': 'str',
        'links': 'list[common.v1.response.ApiLink]',
        'tenant_id': 'str',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'cluster_name': 'clusterName',
        'external_ip': 'externalIP',
        'cvm_i_ps': 'cvmIPs',
        'total_memory_size_bytes': 'totalMemorySizeBytes',
        'current_memory_usage_size_bytes': 'currentMemoryUsageSizeBytes',
        'provisioned_memory_usage_bytes': 'provisionedMemoryUsageBytes',
        'max_vm_memory_size_bytes': 'maxVmMemorySizeBytes',
        'available_memory_size_bytes': 'availableMemorySizeBytes',
        'largest_powered_off_vm_memory': 'largestPoweredOffVMMemory',
        'total_v_cpu_count': 'totalVCpuCount',
        'current_used_v_cpu_count': 'currentUsedVCpuCount',
        'provisioned_v_cpu_count': 'provisionedVCpuCount',
        'max_vm_v_cpu_size': 'maxVmVCpuSize',
        'available_v_cpu_count': 'availableVCpuCount',
        'largest_powered_off_vmv_cpu': 'largestPoweredOffVMVCpu',
        'total_cpu_hz': 'totalCpuHz',
        'current_used_cpu_hz': 'currentUsedCpuHz',
        'provisioned_cpu_hz': 'provisionedCpuHz',
        'total_storage_capacity_raw_bytes': 'totalStorageCapacityRawBytes',
        'total_storage_capacity_logical_bytes': 'totalStorageCapacityLogicalBytes',
        'total_storage_capacity_logical_with_savings_bytes': 'totalStorageCapacityLogicalWithSavingsBytes',
        'total_storage_usage_bytes': 'totalStorageUsageBytes',
        'total_storage_available_bytes': 'totalStorageAvailableBytes',
        'total_storage_available_logical_bytes': 'totalStorageAvailableLogicalBytes',
        'ext_id': 'extId',
        'links': 'links',
        'tenant_id': 'tenantId',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, cluster_name=None, external_ip=None, cvm_i_ps=None, total_memory_size_bytes=None, current_memory_usage_size_bytes=None, provisioned_memory_usage_bytes=None, max_vm_memory_size_bytes=None, available_memory_size_bytes=None, largest_powered_off_vm_memory=None, total_v_cpu_count=None, current_used_v_cpu_count=None, provisioned_v_cpu_count=None, max_vm_v_cpu_size=None, available_v_cpu_count=None, largest_powered_off_vmv_cpu=None, total_cpu_hz=None, current_used_cpu_hz=None, provisioned_cpu_hz=None, total_storage_capacity_raw_bytes=None, total_storage_capacity_logical_bytes=None, total_storage_capacity_logical_with_savings_bytes=None, total_storage_usage_bytes=None, total_storage_available_bytes=None, total_storage_available_logical_bytes=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
        """ClusterMetrics - a model defined in Swagger
            
        """
        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
        self.__cluster_name = None
        self.__external_ip = None
        self.__cvm_i_ps = None
        self.__total_memory_size_bytes = None
        self.__current_memory_usage_size_bytes = None
        self.__provisioned_memory_usage_bytes = None
        self.__max_vm_memory_size_bytes = None
        self.__available_memory_size_bytes = None
        self.__largest_powered_off_vm_memory = None
        self.__total_v_cpu_count = None
        self.__current_used_v_cpu_count = None
        self.__provisioned_v_cpu_count = None
        self.__max_vm_v_cpu_size = None
        self.__available_v_cpu_count = None
        self.__largest_powered_off_vmv_cpu = None
        self.__total_cpu_hz = None
        self.__current_used_cpu_hz = None
        self.__provisioned_cpu_hz = None
        self.__total_storage_capacity_raw_bytes = None
        self.__total_storage_capacity_logical_bytes = None
        self.__total_storage_capacity_logical_with_savings_bytes = None
        self.__total_storage_usage_bytes = None
        self.__total_storage_available_bytes = None
        self.__total_storage_available_logical_bytes = None
        self.discriminator = None
        if cluster_name is not None:
            self.__cluster_name = cluster_name
        if external_ip is not None:
            self.__external_ip = external_ip
        if cvm_i_ps is not None:
            self.__cvm_i_ps = cvm_i_ps
        if total_memory_size_bytes is not None:
            self.__total_memory_size_bytes = total_memory_size_bytes
        if current_memory_usage_size_bytes is not None:
            self.__current_memory_usage_size_bytes = current_memory_usage_size_bytes
        if provisioned_memory_usage_bytes is not None:
            self.__provisioned_memory_usage_bytes = provisioned_memory_usage_bytes
        if max_vm_memory_size_bytes is not None:
            self.__max_vm_memory_size_bytes = max_vm_memory_size_bytes
        if available_memory_size_bytes is not None:
            self.__available_memory_size_bytes = available_memory_size_bytes
        if largest_powered_off_vm_memory is not None:
            self.__largest_powered_off_vm_memory = largest_powered_off_vm_memory
        if total_v_cpu_count is not None:
            self.__total_v_cpu_count = total_v_cpu_count
        if current_used_v_cpu_count is not None:
            self.__current_used_v_cpu_count = current_used_v_cpu_count
        if provisioned_v_cpu_count is not None:
            self.__provisioned_v_cpu_count = provisioned_v_cpu_count
        if max_vm_v_cpu_size is not None:
            self.__max_vm_v_cpu_size = max_vm_v_cpu_size
        if available_v_cpu_count is not None:
            self.__available_v_cpu_count = available_v_cpu_count
        if largest_powered_off_vmv_cpu is not None:
            self.__largest_powered_off_vmv_cpu = largest_powered_off_vmv_cpu
        if total_cpu_hz is not None:
            self.__total_cpu_hz = total_cpu_hz
        if current_used_cpu_hz is not None:
            self.__current_used_cpu_hz = current_used_cpu_hz
        if provisioned_cpu_hz is not None:
            self.__provisioned_cpu_hz = provisioned_cpu_hz
        if total_storage_capacity_raw_bytes is not None:
            self.__total_storage_capacity_raw_bytes = total_storage_capacity_raw_bytes
        if total_storage_capacity_logical_bytes is not None:
            self.__total_storage_capacity_logical_bytes = total_storage_capacity_logical_bytes
        if total_storage_capacity_logical_with_savings_bytes is not None:
            self.__total_storage_capacity_logical_with_savings_bytes = total_storage_capacity_logical_with_savings_bytes
        if total_storage_usage_bytes is not None:
            self.__total_storage_usage_bytes = total_storage_usage_bytes
        if total_storage_available_bytes is not None:
            self.__total_storage_available_bytes = total_storage_available_bytes
        if total_storage_available_logical_bytes is not None:
            self.__total_storage_available_logical_bytes = total_storage_available_logical_bytes

    def _initialize_object_type(self):
        return 'aiops.v4.clusterMetrics.ClusterMetrics'

    def _initialize_fq_object_type(self):
        return 'aiops.v4.r0.a1.clusterMetrics.ClusterMetrics'


    @property
    def cluster_name(self):
        """`{ str }`
            \nName of the cluster
        """ # noqa: E501
        return self.__cluster_name

    @cluster_name.setter
    def cluster_name(self, cluster_name):

        self.__cluster_name = cluster_name

    @property
    def external_ip(self):
        """`{ common.v1.config.IPv4Address }`
            
        """ # noqa: E501
        return self.__external_ip

    @external_ip.setter
    def external_ip(self, external_ip):

        self.__external_ip = external_ip

    @property
    def cvm_i_ps(self):
        """`{ list[common.v1.config.IPv4Address] }`
            \nCVM IPs of the nodes in the cluster
        """ # noqa: E501
        return self.__cvm_i_ps

    @cvm_i_ps.setter
    def cvm_i_ps(self, cvm_i_ps):

        self.__cvm_i_ps = cvm_i_ps

    @property
    def total_memory_size_bytes(self):
        """`{ int }`
            \nTotal memory size in bytes in the cluster
        """ # noqa: E501
        return self.__total_memory_size_bytes

    @total_memory_size_bytes.setter
    def total_memory_size_bytes(self, total_memory_size_bytes):

        self.__total_memory_size_bytes = total_memory_size_bytes

    @property
    def current_memory_usage_size_bytes(self):
        """`{ int }`
            \nTotal memory size in bytes currently being used by the active VMs
        """ # noqa: E501
        return self.__current_memory_usage_size_bytes

    @current_memory_usage_size_bytes.setter
    def current_memory_usage_size_bytes(self, current_memory_usage_size_bytes):

        self.__current_memory_usage_size_bytes = current_memory_usage_size_bytes

    @property
    def provisioned_memory_usage_bytes(self):
        """`{ int }`
            \nTotal memory size in bytes provisioned for all the VMs
        """ # noqa: E501
        return self.__provisioned_memory_usage_bytes

    @provisioned_memory_usage_bytes.setter
    def provisioned_memory_usage_bytes(self, provisioned_memory_usage_bytes):

        self.__provisioned_memory_usage_bytes = provisioned_memory_usage_bytes

    @property
    def max_vm_memory_size_bytes(self):
        """`{ int }`
            \nLargest possible memory size in bytes for the next VM that can be added
        """ # noqa: E501
        return self.__max_vm_memory_size_bytes

    @max_vm_memory_size_bytes.setter
    def max_vm_memory_size_bytes(self, max_vm_memory_size_bytes):

        self.__max_vm_memory_size_bytes = max_vm_memory_size_bytes

    @property
    def available_memory_size_bytes(self):
        """`{ int }`
            \nTotal amount of available memory in bytes for deploying new VMs
        """ # noqa: E501
        return self.__available_memory_size_bytes

    @available_memory_size_bytes.setter
    def available_memory_size_bytes(self, available_memory_size_bytes):

        self.__available_memory_size_bytes = available_memory_size_bytes

    @property
    def largest_powered_off_vm_memory(self):
        """`{ int }`
            \nPowered OFF VM with the largest memory size
        """ # noqa: E501
        return self.__largest_powered_off_vm_memory

    @largest_powered_off_vm_memory.setter
    def largest_powered_off_vm_memory(self, largest_powered_off_vm_memory):

        self.__largest_powered_off_vm_memory = largest_powered_off_vm_memory

    @property
    def total_v_cpu_count(self):
        """`{ int }`
            \nTotal number of vCPUs in the cluster
        """ # noqa: E501
        return self.__total_v_cpu_count

    @total_v_cpu_count.setter
    def total_v_cpu_count(self, total_v_cpu_count):

        self.__total_v_cpu_count = total_v_cpu_count

    @property
    def current_used_v_cpu_count(self):
        """`{ int }`
            \nTotal number of vCPUs currently being used by the active VMs
        """ # noqa: E501
        return self.__current_used_v_cpu_count

    @current_used_v_cpu_count.setter
    def current_used_v_cpu_count(self, current_used_v_cpu_count):

        self.__current_used_v_cpu_count = current_used_v_cpu_count

    @property
    def provisioned_v_cpu_count(self):
        """`{ int }`
            \nTotal number of vCPUs provisioned for all the VMs
        """ # noqa: E501
        return self.__provisioned_v_cpu_count

    @provisioned_v_cpu_count.setter
    def provisioned_v_cpu_count(self, provisioned_v_cpu_count):

        self.__provisioned_v_cpu_count = provisioned_v_cpu_count

    @property
    def max_vm_v_cpu_size(self):
        """`{ int }`
            \nLargest possible VM size in vCPUs for the next VM that can be added
        """ # noqa: E501
        return self.__max_vm_v_cpu_size

    @max_vm_v_cpu_size.setter
    def max_vm_v_cpu_size(self, max_vm_v_cpu_size):

        self.__max_vm_v_cpu_size = max_vm_v_cpu_size

    @property
    def available_v_cpu_count(self):
        """`{ int }`
            \nTotal number of available VMs for deploying new VMs
        """ # noqa: E501
        return self.__available_v_cpu_count

    @available_v_cpu_count.setter
    def available_v_cpu_count(self, available_v_cpu_count):

        self.__available_v_cpu_count = available_v_cpu_count

    @property
    def largest_powered_off_vmv_cpu(self):
        """`{ int }`
            \nLargest powered OFF VM in terms of vCPU count
        """ # noqa: E501
        return self.__largest_powered_off_vmv_cpu

    @largest_powered_off_vmv_cpu.setter
    def largest_powered_off_vmv_cpu(self, largest_powered_off_vmv_cpu):

        self.__largest_powered_off_vmv_cpu = largest_powered_off_vmv_cpu

    @property
    def total_cpu_hz(self):
        """`{ int }`
            \nTotal amount of CPU in hertz in the cluster
        """ # noqa: E501
        return self.__total_cpu_hz

    @total_cpu_hz.setter
    def total_cpu_hz(self, total_cpu_hz):

        self.__total_cpu_hz = total_cpu_hz

    @property
    def current_used_cpu_hz(self):
        """`{ int }`
            \nTotal amount of CPU in hertz currently being used by the active VMs
        """ # noqa: E501
        return self.__current_used_cpu_hz

    @current_used_cpu_hz.setter
    def current_used_cpu_hz(self, current_used_cpu_hz):

        self.__current_used_cpu_hz = current_used_cpu_hz

    @property
    def provisioned_cpu_hz(self):
        """`{ int }`
            \nTotal amount of CPU in hertz provisioned for all the VMs
        """ # noqa: E501
        return self.__provisioned_cpu_hz

    @provisioned_cpu_hz.setter
    def provisioned_cpu_hz(self, provisioned_cpu_hz):

        self.__provisioned_cpu_hz = provisioned_cpu_hz

    @property
    def total_storage_capacity_raw_bytes(self):
        """`{ int }`
            \nTotal storage in bytes capacity in the cluster
        """ # noqa: E501
        return self.__total_storage_capacity_raw_bytes

    @total_storage_capacity_raw_bytes.setter
    def total_storage_capacity_raw_bytes(self, total_storage_capacity_raw_bytes):

        self.__total_storage_capacity_raw_bytes = total_storage_capacity_raw_bytes

    @property
    def total_storage_capacity_logical_bytes(self):
        """`{ int }`
            \nTotal logical storage in bytes capacity after considering RF
        """ # noqa: E501
        return self.__total_storage_capacity_logical_bytes

    @total_storage_capacity_logical_bytes.setter
    def total_storage_capacity_logical_bytes(self, total_storage_capacity_logical_bytes):

        self.__total_storage_capacity_logical_bytes = total_storage_capacity_logical_bytes

    @property
    def total_storage_capacity_logical_with_savings_bytes(self):
        """`{ int }`
            \nTotal logical storage capacity in bytes after accounting for savings from dedup, compressions,and erasure coding
        """ # noqa: E501
        return self.__total_storage_capacity_logical_with_savings_bytes

    @total_storage_capacity_logical_with_savings_bytes.setter
    def total_storage_capacity_logical_with_savings_bytes(self, total_storage_capacity_logical_with_savings_bytes):

        self.__total_storage_capacity_logical_with_savings_bytes = total_storage_capacity_logical_with_savings_bytes

    @property
    def total_storage_usage_bytes(self):
        """`{ int }`
            \nTotal raw storage usage by the cluster
        """ # noqa: E501
        return self.__total_storage_usage_bytes

    @total_storage_usage_bytes.setter
    def total_storage_usage_bytes(self, total_storage_usage_bytes):

        self.__total_storage_usage_bytes = total_storage_usage_bytes

    @property
    def total_storage_available_bytes(self):
        """`{ int }`
            \nTotal raw storage bytes still available in the cluster
        """ # noqa: E501
        return self.__total_storage_available_bytes

    @total_storage_available_bytes.setter
    def total_storage_available_bytes(self, total_storage_available_bytes):

        self.__total_storage_available_bytes = total_storage_available_bytes

    @property
    def total_storage_available_logical_bytes(self):
        """`{ int }`
            \nTotal logical storage bytes still available in the cluster
        """ # noqa: E501
        return self.__total_storage_available_logical_bytes

    @total_storage_available_logical_bytes.setter
    def total_storage_available_logical_bytes(self, total_storage_available_logical_bytes):

        self.__total_storage_available_logical_bytes = total_storage_available_logical_bytes

    def _to_dict(self, sanitize):
        """
        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
        :param bool sanitize
        """

        result = {}

        for attr, attr_type in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                    value
                ))
            elif hasattr(value, "_to_dict"):
                result[attr] = value._to_dict(sanitize)
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1]._to_dict(sanitize))
                    if hasattr(item[1], "_to_dict") else item,
                    six.iteritems(value)
                ))
            else:
                if sanitize:
                    if value is not None:
                        result[attr] = value
                else:
                    result[attr] = value
        if issubclass(ClusterMetrics, dict):
            for key, value in six.iteritems(self):
                result[key] = value

        return result

    def to_dict(self):
        """Returns the model properties as a dict"""
        return self._to_dict(False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self._to_dict(True))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ClusterMetrics):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

