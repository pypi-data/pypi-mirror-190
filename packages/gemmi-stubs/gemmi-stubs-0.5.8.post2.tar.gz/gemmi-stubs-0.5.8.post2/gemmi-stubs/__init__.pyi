from __future__ import annotations

import typing

from typing import Any, ClassVar, Iterable, Iterator

from . import cif

from .cif import Block, Document

from typing import overload
import numpy as np
import numpy.typing as npt
hc: float

class Addends:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def add_cl_fprime(self, energy: float) -> None: ...
    def clear(self) -> None: ...
    def get(self, arg0: Element) -> float: ...
    def set(self, arg0: Element, arg1: float) -> None: ...
    def subtract_z(self, except_hydrogen: bool = ...) -> None: ...

class AlignmentResult:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def add_gaps(self, s: str, which: int) -> str: ...
    def calculate_identity(self, which: int = ...) -> float: ...
    def cigar_str(self) -> str: ...
    def formatted(self, arg0: str, arg1: str) -> str: ...
    @property
    def match_count(self) -> int: ...
    @property
    def match_string(self) -> str: ...
    @property
    def score(self) -> int: ...

class AlignmentScoring:
    gape: int
    gapo: int
    match: int
    mismatch: int
    def __init__(self) -> None: ...

class Assembly:
    class Gen:
        chains: list[str]
        subchains: list[str]
        def __init__(self) -> None: ...
        @property
        def operators(self) -> Assembly.OperatorList: ...

    class GenList:
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: Assembly.GenList) -> None: ...
        @overload
        def __init__(self, arg0: Iterable[Any]) -> None: ...
        def append(self, x: Assembly.Gen) -> None: ...
        def clear(self) -> None: ...
        @overload
        def extend(self, L: Assembly.GenList) -> None: ...
        @overload
        def extend(self, L: Iterable[Any]) -> None: ...
        def insert(self, i: int, x: Assembly.Gen) -> None: ...
        @overload
        def pop(self) -> Assembly.Gen: ...
        @overload
        def pop(self, i: int) -> Assembly.Gen: ...
        def __bool__(self) -> bool: ...
        @overload
        def __delitem__(self, arg0: int) -> None: ...
        @overload
        def __delitem__(self, arg0: slice) -> None: ...
        @overload
        def __getitem__(self, s: slice) -> Assembly.GenList: ...
        @overload
        def __getitem__(self, arg0: int) -> Assembly.Gen: ...
        def __iter__(self) -> Iterator[Any]: ...
        def __len__(self) -> int: ...
        @overload
        def __setitem__(self, arg0: int, arg1: Assembly.Gen) -> None: ...
        @overload
        def __setitem__(self, arg0: slice, arg1: Assembly.GenList) -> None: ...

    class Operator:
        name: str
        transform: Transform
        type: str
        def __init__(self) -> None: ...

    class OperatorList:
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: Assembly.OperatorList) -> None: ...
        @overload
        def __init__(self, arg0: Iterable[Any]) -> None: ...
        def append(self, x: Assembly.Operator) -> None: ...
        def clear(self) -> None: ...
        @overload
        def extend(self, L: Assembly.OperatorList) -> None: ...
        @overload
        def extend(self, L: Iterable[Any]) -> None: ...
        def insert(self, i: int, x: Assembly.Operator) -> None: ...
        @overload
        def pop(self) -> Assembly.Operator: ...
        @overload
        def pop(self, i: int) -> Assembly.Operator: ...
        def __bool__(self) -> bool: ...
        @overload
        def __delitem__(self, arg0: int) -> None: ...
        @overload
        def __delitem__(self, arg0: slice) -> None: ...
        @overload
        def __getitem__(self, s: slice) -> Assembly.OperatorList: ...
        @overload
        def __getitem__(self, arg0: int) -> Assembly.Operator: ...
        def __iter__(self) -> Iterator[Any]: ...
        def __len__(self) -> int: ...
        @overload
        def __setitem__(self, arg0: int, arg1: Assembly.Operator) -> None: ...
        @overload
        def __setitem__(self, arg0: slice, arg1: Assembly.OperatorList) -> None: ...
    author_determined: bool
    name: str
    oligomeric_details: str
    software_determined: bool
    special_kind: AssemblySpecialKind
    def __init__(self, arg0: str) -> None: ...
    @property
    def generators(self) -> Assembly.GenList: ...

class AssemblyList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: AssemblyList) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Assembly) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: AssemblyList) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Assembly) -> None: ...
    @overload
    def pop(self) -> Assembly: ...
    @overload
    def pop(self, i: int) -> Assembly: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> AssemblyList: ...
    @overload
    def __getitem__(self, arg0: int) -> Assembly: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Assembly) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: AssemblyList) -> None: ...

class AssemblySpecialKind:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    CompleteIcosahedral: ClassVar[AssemblySpecialKind] = ...
    CompletePoint: ClassVar[AssemblySpecialKind] = ...
    NA: ClassVar[AssemblySpecialKind] = ...
    RepresentativeHelical: ClassVar[AssemblySpecialKind] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Asu:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Any: ClassVar[Asu] = ...
    Different: ClassVar[Asu] = ...
    Same: ClassVar[Asu] = ...
    __entries: ClassVar[dict[typing.Any, typing.Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AsuBrick:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def get_extent(self) -> FractionalBox: ...
    def str(self) -> str: ...
    @property
    def incl(self) -> list[bool]: ...
    @property
    def size(self) -> list[int]: ...

class Atom:
    altloc: str
    aniso: SMat33f
    b_iso: float
    calc_flag: CalcFlag
    charge: int
    element: Element
    flag: str
    fraction: float
    name: str
    occ: float
    pos: Position
    serial: int
    tls_group_id: int
    def __init__(self) -> None: ...
    def b_eq(self) -> float: ...
    def clone(self) -> Atom: ...
    def has_altloc(self) -> bool: ...
    def is_hydrogen(self) -> bool: ...
    def padded_name(self) -> str: ...

class AtomAddress:
    __hash__: Any = ...
    altloc: str
    atom_name: str
    chain_name: str
    res_id: ResidueId
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, chain: str, seqid: SeqId, resname: str, atom: str, altloc: str = ...) -> None: ...
    def __eq__(self, arg0: AtomAddress) -> bool: ... # type: ignore[override]
    def __getstate__(self) -> tuple[Any]: ...
    def __setstate__(self, arg0: tuple[Any]) -> None: ...

class AtomGroup:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def name(self) -> str: ...
    def __bool__(self) -> bool: ...
    @overload
    def __getitem__(self, index: int) -> Atom: ...
    @overload
    def __getitem__(self, altloc: str) -> Atom: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...

class AtomicRadiiSet:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Cctbx: ClassVar[AtomicRadiiSet] = ...
    Constant: ClassVar[AtomicRadiiSet] = ...
    Refmac: ClassVar[AtomicRadiiSet] = ...
    VanDerWaals: ClassVar[AtomicRadiiSet] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AxisOrder:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Unknown: ClassVar[AxisOrder] = ...
    XYZ: ClassVar[AxisOrder] = ...
    ZYX: ClassVar[AxisOrder] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Binner:
    class Method:
        __members__: ClassVar[dict[Any, Any]] = ...  # read-only
        Dstar: ClassVar[Binner.Method] = ...
        Dstar2: ClassVar[Binner.Method] = ...
        Dstar3: ClassVar[Binner.Method] = ...
        EqualCount: ClassVar[Binner.Method] = ...
        __entries: ClassVar[dict[Any, Any]] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    cell: UnitCell
    def __init__(self) -> None: ...
    def dmax_of_bin(self, arg0: int) -> float: ...
    def dmin_of_bin(self, arg0: int) -> float: ...
    def get_bin(self, arg0: list[int]) -> int: ...

    @overload
    def get_bins(self, arg0: Mtz) -> npt.NDArray[np.int32]: ...
    @overload
    def get_bins(self, arg0: ReflnBlock) -> npt.NDArray[np.int32]: ...
    @overload
    def get_bins(self, arg0: npt.NDArray[np.int32]) -> npt.NDArray[np.int32]: ...
    def get_bins_from_1_d2(self, arg0: npt.NDArray[np.float64]) -> npt.NDArray[np.int32]: ...
    @overload
    def setup(self, nbins: int, method: Binner.Method, mtz: Mtz, cell: UnitCell = ...) -> int: ...
    @overload
    def setup(self, nbins: int, method: Binner.Method, r: ReflnBlock, cell: UnitCell = ...) -> int: ...
    @overload
    def setup(self, nbins: int, method: Binner.Method, hkl: npt.NDArray[np.int32], cell: UnitCell) -> int: ...
    def setup_from_1_d2(self, nbins: int, method: Binner.Method, inv_d2: npt.NDArray[np.float64], cell: UnitCell) -> int: ...
    @property
    def limits(self) -> list[float]: ...
    @property
    def max_1_d2(self) -> float: ...
    @property
    def min_1_d2(self) -> float: ...
    @property
    def size(self) -> int: ...

class Blob:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @property
    def centroid(self) -> Position: ...
    @property
    def peak_pos(self) -> Position: ...
    @property
    def peak_value(self) -> float: ...
    @property
    def score(self) -> float: ...
    @property
    def volume(self) -> float: ...

class BondIndex:
    def __init__(self, arg0: Model) -> None: ...
    def add_link(self, arg0: Atom, arg1: Atom, arg2: bool) -> None: ...
    def add_monomer_bonds(self, arg0: MonLib) -> None: ...
    def are_linked(self, arg0: Atom, arg1: Atom, arg2: bool) -> bool: ...
    def graph_distance(self, a: Atom, b: Atom, same_index: bool, max_distance: int = ...) -> int: ...

class BondType:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Aromatic: ClassVar[BondType] = ...
    Deloc: ClassVar[BondType] = ...
    Double: ClassVar[BondType] = ...
    Metal: ClassVar[BondType] = ...
    Single: ClassVar[BondType] = ...
    Triple: ClassVar[BondType] = ...
    Unspec: ClassVar[BondType] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class C4322Coef:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def calculate_density_iso(self, r2: float, B: float) -> float: ...
    def calculate_sf(self, stol2: float) -> float: ...
    def get_coefs(self) -> list[float]: ...
    def set_coefs(self, arg0: list[float]) -> None: ...
    @property
    def a(self) -> list[float]: ...
    @property
    def b(self) -> list[float]: ...

class CRA:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def atom_matches(self, arg0: AtomAddress) -> bool: ...
    @property
    def atom(self) -> Atom: ...
    @property
    def chain(self) -> Chain: ...
    @property
    def residue(self) -> Residue: ...

class CalcFlag:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Calculated: ClassVar[CalcFlag] = ...
    Determined: ClassVar[CalcFlag] = ...
    Dummy: ClassVar[CalcFlag] = ...
    NotSet: ClassVar[CalcFlag] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Ccp4Base:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def axis_positions(self) -> list[int]: ...
    def get_extent(self) -> FractionalBox: ...
    def get_skew_transformation(self) -> Transform: ...
    def has_skew_transformation(self) -> bool: ...
    def header_float(self, arg0: int) -> float: ...
    def header_i32(self, arg0: int) -> int: ...
    def header_str(self, w: int, len: int = ...) -> str: ...
    def set_header_float(self, arg0: int, arg1: float) -> None: ...
    def set_header_i32(self, arg0: int, arg1: int) -> None: ...
    def set_header_str(self, arg0: int, arg1: str) -> None: ...

class Ccp4Map(Ccp4Base):
    grid: FloatGrid
    def __init__(self) -> None: ...
    def full_cell(self) -> bool: ...
    def set_extent(self, arg0: FractionalBox) -> None: ...
    def setup(self, default_value: float, mode: MapSetup = ...) -> None: ...
    def update_ccp4_header(self, mode: int = ..., update_stats: bool = ...) -> None: ...
    def write_ccp4_map(self, filename: str) -> None: ...

class Ccp4Mask(Ccp4Base):
    grid: Int8Grid
    def __init__(self) -> None: ...
    def full_cell(self) -> bool: ...
    def set_extent(self, arg0: FractionalBox) -> None: ...
    def setup(self, default_value: int, mode: MapSetup = ...) -> None: ...
    def update_ccp4_header(self, mode: int = ..., update_stats: bool = ...) -> None: ...
    def write_ccp4_map(self, filename: str) -> None: ...

class Chain:
    name: str
    def __init__(self, arg0: str) -> None: ...
    def add_residue(self, residue: Residue, pos: int = ...) -> Residue: ...
    def append_residues(self, new_residues: list[Residue], min_sep: int = ...) -> None: ...
    def calculate_center_of_mass(self) -> Position: ...
    def calculate_mass(self) -> float: ...
    def clone(self) -> Chain: ...
    def count_atom_sites(self, sel: Selection = ...) -> int: ...
    def count_occupancies(self, sel: Selection = ...) -> float: ...
    def first_conformer(self) -> FirstConformerRes: ...
    def get_ligands(self) -> ResidueSpan: ...
    def get_polymer(self) -> ResidueSpan: ...
    def get_subchain(self, arg0: str) -> ResidueSpan: ...
    def get_waters(self) -> ResidueSpan: ...
    def has_entity_types_and_subchains(self) -> tuple[bool,bool]: ...
    def next_residue(self, arg0: Residue) -> Residue: ...
    def previous_residue(self, arg0: Residue) -> Residue: ...
    def subchains(self) -> list[ResidueSpan]: ...
    def trim_to_alanine(self) -> None: ...
    def whole(self) -> ResidueSpan: ...
    @overload
    def __delitem__(self, index: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, pdb_seqid: str) -> ResidueGroup: ...
    @overload
    def __getitem__(self, index: int) -> Residue: ...
    @overload
    def __getitem__(self, arg0: slice) -> list[Residue]: ...
    def __iter__(self) -> Iterator[Residue]: ...
    def __len__(self) -> int: ...

class ChemComp:
    class Atom:
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        def is_hydrogen(self) -> bool: ...
        @property
        def charge(self) -> float: ...
        @property
        def chem_type(self) -> str: ...
        @property
        def el(self) -> Element: ...
        @property
        def id(self) -> str: ...

    class Group:
        __members__: ClassVar[dict[Any, Any]] = ...  # read-only
        Dna: ClassVar[ChemComp.Group] = ...
        DnaRna: ClassVar[ChemComp.Group] = ...
        Furanose: ClassVar[ChemComp.Group] = ...
        Ketopyranose: ClassVar[ChemComp.Group] = ...
        MPeptide: ClassVar[ChemComp.Group] = ...
        NonPolymer: ClassVar[ChemComp.Group] = ...
        Null: ClassVar[ChemComp.Group] = ...
        PPeptide: ClassVar[ChemComp.Group] = ...
        Peptide: ClassVar[ChemComp.Group] = ...
        Pyranose: ClassVar[ChemComp.Group] = ...
        Rna: ClassVar[ChemComp.Group] = ...
        __entries: ClassVar[dict[Any, Any]] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    group: ChemComp.Group
    name: str
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def find_atom(self, arg0: str) -> ChemComp.Atom: ...
    def get_atom(self, arg0: str) -> ChemComp.Atom: ...
    def group_str(self, *args: Any, **kwargs: Any) -> Any: ...
    def remove_hydrogens(self) -> ChemComp: ...
    def set_group(self, arg0: str) -> None: ...
    @property
    def atoms(self) -> ChemCompAtoms: ...
    @property
    def rt(self) -> Restraints: ...

class ChemCompAtoms:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: ChemCompAtoms) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: ChemComp.Atom) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: ChemCompAtoms) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: ChemComp.Atom) -> None: ...
    @overload
    def pop(self) -> ChemComp.Atom: ...
    @overload
    def pop(self, i: int) -> ChemComp.Atom: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> ChemCompAtoms: ...
    @overload
    def __getitem__(self, arg0: int) -> ChemComp.Atom: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: ChemComp.Atom) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: ChemCompAtoms) -> None: ...

class ChemCompMap:
    def __init__(self) -> None: ...
    def items(self) -> ItemsView: ...
    def keys(self) -> KeysView: ...
    def values(self) -> ValuesView: ...
    def __bool__(self) -> bool: ...
    @overload
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __contains__(self, arg0: object) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __getitem__(self, arg0: str) -> ChemComp: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1: ChemComp) -> None: ...

class ChemLink:
    class Side:
        comp: str
        group: ChemComp.Group
        mod: str
        def __init__(self) -> None: ...
    id: str
    name: str
    rt: Restraints
    side1: ChemLink.Side
    side2: ChemLink.Side
    def __init__(self) -> None: ...

class ChemLinkMap:
    def __init__(self) -> None: ...
    def items(self) -> ItemsView: ...
    def keys(self) -> KeysView: ...
    def values(self) -> ValuesView: ...
    def __bool__(self) -> bool: ...
    @overload
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __contains__(self, arg0: object) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __getitem__(self, arg0: str) -> ChemLink: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1: ChemLink) -> None: ...

class ChemMod:
    comp_id: str
    group_id: str
    id: str
    name: str
    rt: Restraints
    def __init__(self) -> None: ...

class ChemModMap:
    def __init__(self) -> None: ...
    def items(self) -> ItemsView: ...
    def keys(self) -> KeysView: ...
    def values(self) -> ValuesView: ...
    def __bool__(self) -> bool: ...
    @overload
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __contains__(self, arg0: object) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __getitem__(self, arg0: str) -> ChemMod: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1: ChemMod) -> None: ...

class ChiralityType:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Both: ClassVar[ChiralityType] = ...
    Negative: ClassVar[ChiralityType] = ...
    Positive: ClassVar[ChiralityType] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CifToMtz:
    history: list[str]
    spec_lines: list[str]
    title: str
    def __init__(self) -> None: ...
    def convert_block_to_mtz(self, arg0: ReflnBlock) -> Mtz: ...

class CifWalk:
    def __init__(self, arg0: str) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class ComplexAsuData:
    spacegroup: SpaceGroup
    unit_cell: UnitCell
    def __init__(self, cell: UnitCell, sg: SpaceGroup, miller_array: npt.NDArray[np.int32], value_array: npt.NDArray[np.complex64]) -> None: ...
    def calculate_correlation(self, arg0: ComplexAsuData) -> ComplexCorrelation: ...
    def copy(self) -> ComplexAsuData: ...
    def count_equal_values(self, arg0: ComplexAsuData) -> int: ...
    def data_fits_into(self, size: list[int]) -> bool: ...
    def ensure_asu(self, tnt_asu: bool = ...) -> None: ...
    def ensure_sorted(self) -> None: ...
    def get_f_phi_on_grid(self, size: list[int], half_l: bool = ..., order: AxisOrder = ...) -> ReciprocalComplexGrid: ...
    def get_size_for_hkl(self, min_size: list[int] = ..., sample_rate: float = ...) -> list[int]: ...
    def make_1_d2_array(self) -> npt.NDArray[np.float32]: ...
    def make_d_array(self) -> npt.NDArray[np.float32]: ...
    def transform_f_phi_to_map(self, min_size: list[int] = ..., sample_rate: float = ..., exact_size: list[int] = ..., order: AxisOrder = ...) -> FloatGrid: ...
    def __getitem__(self, index: int) -> ComplexHklValue: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @property
    def miller_array(self) -> npt.NDArray[np.int32]: ...
    @property
    def value_array(self) -> npt.NDArray[np.complex64]: ...

class ComplexCorrelation:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def coefficient(self) -> complex: ...
    def mean_ratio(self) -> float: ...
    @property
    def n(self) -> int: ...

class ComplexGridBase(GridMeta):
    class Point:
        value: complex
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        @property
        def u(self) -> int: ...
        @property
        def v(self) -> int: ...
        @property
        def w(self) -> int: ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def fill(self, value: complex) -> None: ...
    def index_to_point(self, arg0: int) -> ComplexGridBase.Point: ...
    def point_to_index(self, arg0: ComplexGridBase.Point) -> int: ...
    def sum(self) -> complex: ...
    def __iter__(self) -> Iterator[Any]: ...
    @property
    def array(self) -> npt.NDArray[np.complex64]: ...

class ComplexHklValue:
    value: complex
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @property
    def hkl(self) -> list[int]: ...

class Connection:
    asu: Asu
    link_id: str
    name: str
    partner1: AtomAddress
    partner2: AtomAddress
    reported_distance: float
    type: ConnectionType
    def __init__(self) -> None: ...

class ConnectionList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: ConnectionList) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Connection) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: ConnectionList) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Connection) -> None: ...
    @overload
    def pop(self) -> Connection: ...
    @overload
    def pop(self, i: int) -> Connection: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> ConnectionList: ...
    @overload
    def __getitem__(self, arg0: int) -> Connection: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Connection) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: ConnectionList) -> None: ...

class ConnectionType:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Covale: ClassVar[ConnectionType] = ...
    Disulf: ClassVar[ConnectionType] = ...
    Hydrog: ClassVar[ConnectionType] = ...
    MetalC: ClassVar[ConnectionType] = ...
    Unknown: ClassVar[ConnectionType] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ContactSearch:
    class Ignore:
        __members__: ClassVar[dict[Any, Any]] = ...  # read-only
        AdjacentResidues: ClassVar[ContactSearch.Ignore] = ...
        Nothing: ClassVar[ContactSearch.Ignore] = ...
        SameAsu: ClassVar[ContactSearch.Ignore] = ...
        SameChain: ClassVar[ContactSearch.Ignore] = ...
        SameResidue: ClassVar[ContactSearch.Ignore] = ...
        __entries: ClassVar[dict[Any, Any]] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Result:
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        @property
        def dist(self) -> float: ...
        @property
        def image_idx(self) -> int: ...
        @property
        def partner1(self) -> CRA: ...
        @property
        def partner2(self) -> CRA: ...
    ignore: ContactSearch.Ignore
    min_occupancy: float
    search_radius: float
    special_pos_cutoff_sq: float
    twice: bool
    def __init__(self, arg0: float) -> None: ...
    def find_contacts(self, arg0: NeighborSearch) -> list[ContactSearch.Result]: ...
    def get_radius(self, arg0: Element) -> float: ...
    def set_radius(self, arg0: Element, arg1: float) -> None: ...
    def setup_atomic_radii(self, arg0: float, arg1: float) -> None: ...

class CoorFileWalk:
    def __init__(self, arg0: str) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class CoorFormat:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    ChemComp: ClassVar[CoorFormat] = ...
    Detect: ClassVar[CoorFormat] = ...
    Mmcif: ClassVar[CoorFormat] = ...
    Mmjson: ClassVar[CoorFormat] = ...
    Pdb: ClassVar[CoorFormat] = ...
    Unknown: ClassVar[CoorFormat] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Correlation:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def coefficient(self) -> float: ...
    def mean_ratio(self) -> float: ...
    @property
    def n(self) -> int: ...

class CraGenerator:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class CrystalSystem:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Cubic: ClassVar[CrystalSystem] = ...
    Hexagonal: ClassVar[CrystalSystem] = ...
    Monoclinic: ClassVar[CrystalSystem] = ...
    Orthorhombic: ClassVar[CrystalSystem] = ...
    Tetragonal: ClassVar[CrystalSystem] = ...
    Triclinic: ClassVar[CrystalSystem] = ...
    Trigonal: ClassVar[CrystalSystem] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DataType:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Anomalous: ClassVar[DataType] = ...
    Mean: ClassVar[DataType] = ...
    Unknown: ClassVar[DataType] = ...
    Unmerged: ClassVar[DataType] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DensityCalculatorE:
    addends: Addends
    blur: float
    cutoff: float
    d_min: float
    rate: float
    def __init__(self) -> None: ...
    def add_atom_density_to_grid(self, arg0: Atom) -> None: ...
    def add_c_contribution_to_grid(self, arg0: Atom, arg1: float) -> None: ...
    def add_model_density_to_grid(self, arg0: Model) -> None: ...
    def estimate_radius(self, arg0: Atom) -> float: ...
    def initialize_grid(self) -> None: ...
    def mott_bethe_factor(self, arg0: list[int]) -> float: ...
    def put_model_density_on_grid(self, arg0: Model) -> None: ...
    def reciprocal_space_multiplier(self, arg0: float) -> float: ...
    def set_grid_cell_and_spacegroup(self, arg0: Structure) -> None: ...
    def set_refmac_compatible_blur(self, arg0: Model) -> None: ...
    @property
    def grid(self) -> FloatGrid: ...

class DensityCalculatorN:
    addends: Addends
    blur: float
    cutoff: float
    d_min: float
    rate: float
    def __init__(self) -> None: ...
    def add_atom_density_to_grid(self, arg0: Atom) -> None: ...
    def add_c_contribution_to_grid(self, arg0: Atom, arg1: float) -> None: ...
    def add_model_density_to_grid(self, arg0: Model) -> None: ...
    def estimate_radius(self, arg0: Atom) -> float: ...
    def initialize_grid(self) -> None: ...
    def mott_bethe_factor(self, arg0: list[int]) -> float: ...
    def put_model_density_on_grid(self, arg0: Model) -> None: ...
    def reciprocal_space_multiplier(self, arg0: float) -> float: ...
    def set_grid_cell_and_spacegroup(self, arg0: Structure) -> None: ...
    def set_refmac_compatible_blur(self, arg0: Model) -> None: ...
    @property
    def grid(self) -> FloatGrid: ...

class DensityCalculatorX:
    addends: Addends
    blur: float
    cutoff: float
    d_min: float
    rate: float
    def __init__(self) -> None: ...
    def add_atom_density_to_grid(self, arg0: Atom) -> None: ...
    def add_c_contribution_to_grid(self, arg0: Atom, arg1: float) -> None: ...
    def add_model_density_to_grid(self, arg0: Model) -> None: ...
    def estimate_radius(self, arg0: Atom) -> float: ...
    def initialize_grid(self) -> None: ...
    def mott_bethe_factor(self, arg0: list[int]) -> float: ...
    def put_model_density_on_grid(self, arg0: Model) -> None: ...
    def reciprocal_space_multiplier(self, arg0: float) -> float: ...
    def set_grid_cell_and_spacegroup(self, arg0: Structure) -> None: ...
    def set_refmac_compatible_blur(self, arg0: Model) -> None: ...
    @property
    def grid(self) -> FloatGrid: ...

class Element:
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    # def __eq__(self, arg0: Element) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def atomic_number(self) -> int: ...
    @property
    def c4322(self) -> C4322Coef: ...
    @property
    def covalent_r(self) -> float: ...
    @property
    def is_hydrogen(self) -> bool: ...
    @property
    def is_metal(self) -> bool: ...
    @property
    def it92(self) -> IT92Coef: ...
    @property
    def name(self) -> str: ...
    @property
    def neutron92(self) -> Neutron92: ...
    @property
    def vdw_r(self) -> float: ...
    @property
    def weight(self) -> float: ...

class Entity:
    entity_type: EntityType
    full_sequence: list[str]
    name: str
    polymer_type: PolymerType
    sifts_unp_acc: list[str]
    subchains: list[str]
    def __init__(self, arg0: str) -> None: ...
    def first_mon(self, *args: Any, **kwargs: Any) -> Any: ...

class EntityList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: EntityList) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Entity) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: EntityList) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Entity) -> None: ...
    @overload
    def pop(self) -> Entity: ...
    @overload
    def pop(self, i: int) -> Entity: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> EntityList: ...
    @overload
    def __getitem__(self, arg0: int) -> Entity: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Entity) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: EntityList) -> None: ...

class EntityType:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    NonPolymer: ClassVar[EntityType] = ...
    Polymer: ClassVar[EntityType] = ...
    Unknown: ClassVar[EntityType] = ...
    Water: ClassVar[EntityType] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FTransform(Transform):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def apply(self, arg0: Fractional) -> Fractional: ... # type: ignore[override]

class FirstConformerAtoms:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class FirstConformerRes:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class FirstConformerResSpan:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class FloatAsuData:
    spacegroup: SpaceGroup
    unit_cell: UnitCell
    def __init__(self, cell: UnitCell, sg: SpaceGroup, miller_array: npt.NDArray[np.int32], value_array: npt.NDArray[np.float32]) -> None: ...
    def calculate_correlation(self, arg0: FloatAsuData) -> Correlation: ...
    def copy(self) -> FloatAsuData: ...
    def count_equal_values(self, arg0: FloatAsuData) -> int: ...
    def ensure_asu(self, tnt_asu: bool = ...) -> None: ...
    def ensure_sorted(self) -> None: ...
    def make_1_d2_array(self) -> npt.NDArray[np.float32]: ...
    def make_d_array(self) -> npt.NDArray[np.float32]: ...
    def __getitem__(self, index: int) -> FloatHklValue: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @property
    def miller_array(self) -> npt.NDArray[np.int32]: ...
    @property
    def value_array(self) -> npt.NDArray[np.float32]: ...

class FloatGrid(FloatGridBase):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, nx: int, ny: int, nz: int) -> None: ...
    @overload
    def __init__(self, arg0: npt.NDArray[np.float32], cell: UnitCell = ..., spacegroup: SpaceGroup = ...) -> None: ...
    def add_soft_edge_to_mask(self, arg0: float) -> None: ...
    def change_values(self, old_value: float, new_value: float) -> None: ...
    def clone(self) -> FloatGrid: ...
    def copy_metadata_from(self, arg0: GridMeta) -> None: ...
    def get_nearest_point(self, arg0: Position) -> FloatGridBase.Point: ...
    def get_point(self, arg0: int, arg1: int, arg2: int) -> FloatGridBase.Point: ...
    def get_subarray(self, start: list[int], shape: list[int]) -> npt.NDArray[np.float32]: ...
    def get_value(self, arg0: int, arg1: int, arg2: int) -> float: ...
    @overload
    def interpolate_value(self, arg0: Fractional) -> float: ...
    @overload
    def interpolate_value(self, arg0: Position) -> float: ...
    def interpolate_values(self, arg0: npt.NDArray[np.float32], arg1: Transform, order: int = ...) -> None: ...
    def mask_points_in_constant_radius(self, model: Model, radius: float, value: float) -> None: ...
    def masked_asu(self) -> MaskedFloatGrid: ...
    def normalize(self) -> None: ...
    def point_to_fractional(self, arg0: FloatGridBase.Point) -> Fractional: ...
    def point_to_position(self, arg0: FloatGridBase.Point) -> Position: ...
    def resample_to(self, dest: FloatGrid, order: int) -> None: ...
    def set_points_around(self, position: Position, radius: float, value: float, use_pbc: bool = ...) -> None: ...
    def set_size(self, arg0: int, arg1: int, arg2: int) -> None: ...
    def set_size_from_spacing(self, spacing: float, rounding: GridSizeRounding) -> None: ...
    def set_subarray(self, arr: npt.NDArray[np.float32], start: list[int]) -> None: ...
    def set_unit_cell(self, arg0: UnitCell) -> None: ...
    def set_value(self, arg0: int, arg1: int, arg2: int, arg3: float) -> None: ...
    def setup_from(self, st: Structure, spacing: float) -> None: ...
    def symmetrize_abs_max(self) -> None: ...
    def symmetrize_max(self) -> None: ...
    def symmetrize_min(self) -> None: ...
    def symmetrize_sum(self) -> None: ...
    @overload
    def tricubic_interpolation(self, arg0: Fractional) -> float: ...
    @overload
    def tricubic_interpolation(self, arg0: Position) -> float: ...
    def tricubic_interpolation_der(self, arg0: Fractional) -> list[float]: ...
    @property
    def spacing(self) -> tuple[float, float, float]: ...

class FloatGridBase(GridMeta):
    class Point:
        value: float
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        @property
        def u(self) -> int: ...
        @property
        def v(self) -> int: ...
        @property
        def w(self) -> int: ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def calculate_correlation(self, arg0: FloatGridBase) -> Correlation: ...
    def fill(self, value: float) -> None: ...
    def get_nonzero_extent(self) -> FractionalBox: ...
    def index_to_point(self, arg0: int) -> FloatGridBase.Point: ...
    def point_to_index(self, arg0: FloatGridBase.Point) -> int: ...
    def sum(self) -> float: ...
    def __iter__(self) -> Iterator[Any]: ...
    @property
    def array(self) -> npt.NDArray[np.float32]: ...

class FloatHklValue:
    value: float
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @property
    def hkl(self) -> list[int]: ...

class Fractional(Vec3):
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...
    def wrap_to_unit(self) -> Fractional: ...
    def __add__(self, arg0: Fractional) -> Fractional: ... # type: ignore[override]
    def __getitem__(self, arg0: int) -> float: ...
    def __sub__(self, arg0: Fractional) -> Fractional: ...# type: ignore[override]

class FractionalBox:
    maximum: Fractional
    minimum: Fractional
    def __init__(self) -> None: ...
    def add_margin(self, arg0: float) -> None: ...
    def extend(self, arg0: Fractional) -> None: ...
    def get_size(self) -> Fractional: ...

class GridMeta:
    spacegroup: SpaceGroup
    unit_cell: UnitCell
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def get_fractional(self, arg0: int, arg1: int, arg2: int) -> Fractional: ...
    def get_position(self, arg0: int, arg1: int, arg2: int) -> Position: ...
    @property
    def axis_order(self) -> AxisOrder: ...
    @property
    def nu(self) -> int: ...
    @property
    def nv(self) -> int: ...
    @property
    def nw(self) -> int: ...
    @property
    def point_count(self) -> int: ...
    @property
    def shape(self) -> tuple[int, int, int]: ...

class GridSizeRounding:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Down: ClassVar[GridSizeRounding] = ...
    Nearest: ClassVar[GridSizeRounding] = ...
    Up: ClassVar[GridSizeRounding] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GroupOps:
    __hash__: Any = ...
    cen_ops: list[list[int]]
    sym_ops: list[Op]
    def __init__(self, arg0: list[Op]) -> None: ...
    def add_inversion(self) -> bool: ...
    def add_missing_elements(self) -> None: ...
    def centric_flag_array(self, arg0: npt.NDArray[np.int32]) -> npt.NDArray[np.bool_]: ...
    def change_basis_backward(self, cob: Op) -> None: ...
    def change_basis_forward(self, cob: Op) -> None: ...
    def derive_symmorphic(self) -> GroupOps: ...
    def epsilon_factor(self, arg0: list[int]) -> int: ...
    def epsilon_factor_array(self, arg0: npt.NDArray[np.int32]) -> npt.NDArray[np.int32]: ...
    def epsilon_factor_without_centering(self, arg0: list[int]) -> int: ...
    def epsilon_factor_without_centering_array(self, arg0: npt.NDArray[np.int32]) -> npt.NDArray[np.int32]: ...
    def find_centering(self) -> str: ...
    def find_grid_factors(self) -> list[int]: ...
    def has_same_centring(self, arg0: GroupOps) -> bool: ...
    def has_same_rotations(self, arg0: GroupOps) -> bool: ...
    def is_centrosymmetric(self) -> bool: ...
    def is_reflection_centric(self, arg0: list[int]) -> bool: ...
    def is_systematically_absent(self, arg0: list[int]) -> bool: ...
    def systematic_absences(self, arg0: npt.NDArray[np.int32]) -> npt.NDArray[np.bool_]: ...
    def __deepcopy__(self, memo: dict[Any, Any]) -> GroupOps: ...
    def __eq__(self, arg0: GroupOps) -> bool: ... # type: ignore[override]
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...

class GruberVector:
    @overload
    def __init__(self, arg0: list[float]) -> None: ...
    @overload
    def __init__(self, cell: UnitCell, sg: SpaceGroup, track_change_of_basis: bool = ...) -> None: ...
    @overload
    def __init__(self, cell: UnitCell, centring: str, track_change_of_basis: bool = ...) -> None: ...
    def buerger_reduce(self) -> int: ...
    def cell_parameters(self) -> tuple[float, float, float, float, float, float]: ...
    def get_cell(self) -> UnitCell: ...
    def is_buerger(self, epsilon: float = ...) -> bool: ...
    def is_niggli(self, epsilon: float = ...) -> bool: ...
    def is_normalized(self) -> bool: ...
    def niggli_reduce(self, epsilon: float = ..., iteration_limit: int = ...) -> int: ...
    def niggli_step(self, epsilon: float) -> bool: ...
    def normalize(self, epsilon: float = ...) -> None: ...
    def selling(self) -> SellingVector: ...
    @property
    def change_of_basis(self) -> Op: ...
    @property
    def parameters(self) -> tuple[float, float, float, float, float, float]: ...

class Helix:
    class HelixClass:
        __members__: ClassVar[dict[Any, Any]] = ...  # read-only
        Helix27: ClassVar[Helix.HelixClass] = ...
        HelixPolyProlineNone: ClassVar[Helix.HelixClass] = ...
        LAlpha: ClassVar[Helix.HelixClass] = ...
        LGamma: ClassVar[Helix.HelixClass] = ...
        LOmega: ClassVar[Helix.HelixClass] = ...
        R310: ClassVar[Helix.HelixClass] = ...
        RAlpha: ClassVar[Helix.HelixClass] = ...
        RGamma: ClassVar[Helix.HelixClass] = ...
        ROmega: ClassVar[Helix.HelixClass] = ...
        RPi: ClassVar[Helix.HelixClass] = ...
        UnknownHelix: ClassVar[Helix.HelixClass] = ...
        __entries: ClassVar[dict[Any, Any]] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    end: AtomAddress
    length: int
    pdb_helix_class: Helix.HelixClass
    start: AtomAddress
    def __init__(self) -> None: ...

class HelixList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: HelixList) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Helix) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: HelixList) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Helix) -> None: ...
    @overload
    def pop(self) -> Helix: ...
    @overload
    def pop(self, i: int) -> Helix: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> HelixList: ...
    @overload
    def __getitem__(self, arg0: int) -> Helix: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Helix) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: HelixList) -> None: ...

class HklMatch:
    def __init__(self, hkl: npt.NDArray[np.int32], ref: npt.NDArray[np.int32]) -> None: ...
    def aligned(self, arg0: npt.NDArray[np.float64]) -> npt.NDArray[np.float64]: ...
    @property
    def pos(self) -> list[int]: ...

class HowToNameCopiedChain:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    AddNumber: ClassVar[HowToNameCopiedChain] = ...
    Dup: ClassVar[HowToNameCopiedChain] = ...
    Short: ClassVar[HowToNameCopiedChain] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class HydrogenChange:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    NoChange: ClassVar[HydrogenChange] = ...
    ReAdd: ClassVar[HydrogenChange] = ...
    ReAddButWater: ClassVar[HydrogenChange] = ...
    Remove: ClassVar[HydrogenChange] = ...
    Shift: ClassVar[HydrogenChange] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IT92Coef:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def calculate_density_iso(self, r2: npt.NDArray[np.float64], B: float) -> object: ...
    def calculate_sf(self, stol2: npt.NDArray[np.float64]) -> object: ...
    def get_coefs(self) -> list[float]: ...
    def set_coefs(self, arg0: list[float]) -> None: ...
    @property
    def a(self) -> list[float]: ...
    @property
    def b(self) -> list[float]: ...
    @property
    def c(self) -> float: ...

class InfoMap:
    def __init__(self) -> None: ...
    def items(self) -> ItemsView: ...
    def keys(self) -> KeysView: ...
    def values(self) -> ValuesView: ...
    def __bool__(self) -> bool: ...
    @overload
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __contains__(self, arg0: object) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __getitem__(self, arg0: str) -> str: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1: str) -> None: ...

class Int8Grid(Int8GridBase):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, nx: int, ny: int, nz: int) -> None: ...
    @overload
    def __init__(self, arg0: npt.NDArray[np.int8], cell: UnitCell = ..., spacegroup: SpaceGroup = ...) -> None: ...
    def change_values(self, old_value: int, new_value: int) -> None: ...
    def clone(self) -> Int8Grid: ...
    def copy_metadata_from(self, arg0: GridMeta) -> None: ...
    def get_nearest_point(self, arg0: Position) -> Int8GridBase.Point: ...
    def get_point(self, arg0: int, arg1: int, arg2: int) -> Int8GridBase.Point: ...
    def get_subarray(self, start: list[int], shape: list[int]) -> npt.NDArray[np.int8]: ...
    def get_value(self, arg0: int, arg1: int, arg2: int) -> int: ...
    def mask_points_in_constant_radius(self, model: Model, radius: float, value: int) -> None: ...
    def masked_asu(self) -> MaskedInt8Grid: ...
    def point_to_fractional(self, arg0: Int8GridBase.Point) -> Fractional: ...
    def point_to_position(self, arg0: Int8GridBase.Point) -> Position: ...
    def resample_to(self, dest: Int8Grid, order: int) -> None: ...
    def set_points_around(self, position: Position, radius: float, value: int, use_pbc: bool = ...) -> None: ...
    def set_size(self, arg0: int, arg1: int, arg2: int) -> None: ...
    def set_size_from_spacing(self, spacing: float, rounding: GridSizeRounding) -> None: ...
    def set_subarray(self, arr: npt.NDArray[np.int8], start: list[int]) -> None: ...
    def set_unit_cell(self, arg0: UnitCell) -> None: ...
    def set_value(self, arg0: int, arg1: int, arg2: int, arg3: int) -> None: ...
    def setup_from(self, st: Structure, spacing: float) -> None: ...
    def symmetrize_abs_max(self) -> None: ...
    def symmetrize_max(self) -> None: ...
    def symmetrize_min(self) -> None: ...
    def symmetrize_sum(self) -> None: ...
    @property
    def spacing(self) -> tuple[float, float, float]: ...

class Int8GridBase(GridMeta):
    class Point:
        value: int
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        @property
        def u(self) -> int: ...
        @property
        def v(self) -> int: ...
        @property
        def w(self) -> int: ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def fill(self, value: int) -> None: ...
    def get_nonzero_extent(self) -> FractionalBox: ...
    def index_to_point(self, arg0: int) -> Int8GridBase.Point: ...
    def point_to_index(self, arg0: Int8GridBase.Point) -> int: ...
    def sum(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...
    @property
    def array(self) -> npt.NDArray[np.int8]: ...

class IntAsuData:
    spacegroup: SpaceGroup
    unit_cell: UnitCell
    def __init__(self, cell: UnitCell, sg: SpaceGroup, miller_array: npt.NDArray[np.int32], value_array: npt.NDArray[np.int32]) -> None: ...
    def copy(self) -> IntAsuData: ...
    def count_equal_values(self, arg0: IntAsuData) -> int: ...
    def ensure_asu(self, tnt_asu: bool = ...) -> None: ...
    def ensure_sorted(self) -> None: ...
    def make_1_d2_array(self) -> npt.NDArray[np.float32]: ...
    def make_d_array(self) -> npt.NDArray[np.float32]: ...
    def __getitem__(self, index: int) -> IntHklValue: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @property
    def miller_array(self) -> npt.NDArray[np.int32]: ...
    @property
    def value_array(self) -> npt.NDArray[np.int32]: ...

class IntHklValue:
    value: int
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @property
    def hkl(self) -> list[int]: ...

class Intensities:
    spacegroup: SpaceGroup
    type: DataType
    unit_cell: UnitCell
    def __init__(self) -> None: ...
    def merge_in_place(self, itype: DataType) -> None: ...
    def read_mtz(self, mtz: Mtz, type: DataType) -> None: ...
    def remove_systematic_absences(self) -> None: ...
    def resolution_range(self) -> list[float]: ...
    def set_data(self, cell: UnitCell, sg: SpaceGroup, miller_array: npt.NDArray[np.int32], value_array: npt.NDArray[np.float64], sigma_array: npt.NDArray[np.float64]) -> None: ...
    @property
    def isign_array(self) -> npt.NDArray[np.int16]: ...
    @property
    def miller_array(self) -> npt.NDArray[np.int32]: ...
    @property
    def nobs_array(self) -> npt.NDArray[np.int16]: ...
    @property
    def sigma_array(self) -> npt.NDArray[np.float64]: ...
    @property
    def value_array(self) -> npt.NDArray[np.float64]: ...

class ItemsView:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...

class KeysView:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @overload
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __contains__(self, arg0: object) -> bool: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...

class LinkHunt:
    class Match:
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        @property
        def bond_length(self) -> float: ...
        @property
        def chem_link(self) -> ChemLink: ...
        @property
        def chem_link_count(self) -> int: ...
        @property
        def conn(self) -> Connection: ...
        @property
        def cra1(self) -> CRA: ...
        @property
        def cra2(self) -> CRA: ...
        @property
        def same_image(self) -> bool: ...
    def __init__(self) -> None: ...
    def find_possible_links(self, st: Structure, bond_margin: float, radius_margin: float, ignore: ContactSearch.Ignore = ...) -> list[LinkHunt.Match]: ...
    def index_chem_links(self, monlib: MonLib, use_alias: bool = ...) -> None: ...

class MapSetup:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    Full: ClassVar[MapSetup] = ...
    NoSymmetry: ClassVar[MapSetup] = ...
    ReorderOnly: ClassVar[MapSetup] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MaskedFloatGrid:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    @property
    def grid(self) -> FloatGrid: ...
    @property
    def mask_array(self) -> npt.NDArray[np.int8]: ...

class MaskedInt8Grid:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    @property
    def grid(self) -> Int8Grid: ...
    @property
    def mask_array(self) -> npt.NDArray[np.int8]: ...

class Mat33:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[list[float]]) -> None: ...
    def approx(self, other: Mat33, epsilon: float) -> bool: ...
    def column_copy(self, arg0: int) -> Vec3: ...
    def determinant(self) -> float: ...
    def fromlist(self, arg0: list[list[float]]) -> None: ...
    def inverse(self) -> Mat33: ...
    def is_identity(self) -> bool: ...
    def left_multiply(self, arg0: Vec3) -> Vec3: ...
    @overload
    def multiply(self, arg0: Mat33) -> Mat33: ...
    @overload
    def multiply(self, arg0: Vec3) -> Vec3: ...
    def multiply_by_diagonal(self, arg0: Vec3) -> Mat33: ...
    def row_copy(self, arg0: int) -> Vec3: ...
    def tolist(self) -> list[list[float]]: ...
    def trace(self) -> float: ...
    def transpose(self) -> Mat33: ...
    def __add__(self, arg0: Mat33) -> Mat33: ...
    def __matmul__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __sub__(self, arg0: Mat33) -> Mat33: ...

class Metadata:
    authors: list[str]
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class MmcifOutputGroups:
    assembly: bool
    atom_type: bool
    atoms: bool
    author: bool
    block_name: bool
    cell: bool
    chem_comp: bool
    cis: bool
    conn: bool
    database_status: bool
    diffrn: bool
    entity: bool
    entity_poly: bool
    entity_poly_seq: bool
    entry: bool
    exptl: bool
    group_pdb: bool
    ncs: bool
    origx: bool
    refine: bool
    reflns: bool
    scale: bool
    software: bool
    struct_asym: bool
    struct_biol: bool
    struct_conf: bool
    struct_ref: bool
    struct_sheet: bool
    symmetry: bool
    title_keywords: bool
    tls: bool
    def __init__(self, all: bool, **kwargs: Any) -> None: ...

class Model:
    name: str
    def __init__(self, arg0: str) -> None: ...
    @overload
    def add_chain(self, chain: Chain, pos: int = ..., unique_name: bool = ...) -> Chain: ...
    @overload
    def add_chain(self, name: str) -> Chain: ...
    def all(self) -> CraGenerator: ...
    def calculate_center_of_mass(self) -> Position: ...
    def calculate_mass(self) -> float: ...
    def clone(self) -> Model: ...
    def count_atom_sites(self, sel: Selection = ...) -> int: ...
    def count_hydrogen_sites(self) -> int: ...
    def count_occupancies(self, sel: Selection = ...) -> float: ...
    def find_chain(self, name: str) -> Chain: ...
    def find_cra(self, arg0: AtomAddress, ignore_segment: bool = ...) -> CRA: ...
    def find_last_chain(self, name: str) -> Chain: ...
    def find_residue_group(self, chain: str, seqid: SeqId) -> ResidueGroup: ...
    def get_all_residue_names(self) -> list[str]: ...
    def get_subchain(self, name: str) -> ResidueSpan: ...
    def has_hydrogen(self) -> bool: ...
    def remove_alternative_conformations(self) -> None: ...
    def remove_chain(self, name: str) -> None: ...
    def remove_hydrogens(self) -> None: ...
    def remove_ligands_and_waters(self) -> None: ...
    def remove_waters(self) -> None: ...
    def sole_residue(self, chain: str, seqid: SeqId) -> Residue: ...
    def split_chains_by_segments(self, arg0: HowToNameCopiedChain) -> None: ...
    def subchains(self) -> list[ResidueSpan]: ...
    def transform_pos_and_adp(self, tr: Transform) -> None: ...
    @overload
    def __delitem__(self, name: str) -> None: ...
    @overload
    def __delitem__(self, index: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, index: int) -> Chain: ...
    @overload
    def __getitem__(self, name: str) -> Chain: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...

class MonLib:
    def __init__(self) -> None: ...
    def add_monomer_if_present(self, arg0: Block) -> None: ...
    def get_link(self, link_id: str) -> ChemLink: ...
    def get_mod(self, name: str) -> ChemMod: ...
    def insert_chemcomps(self, arg0: Document) -> None: ...
    def insert_chemlinks(self, arg0: Document) -> None: ...
    def insert_chemmods(self, arg0: Document) -> None: ...
    def insert_comp_list(self, arg0: Document) -> None: ...
    def match_link(self, res1: Residue, atom1: str, res2: Residue, atom2: str, altloc: str, min_bond_sq: float = ...) -> tuple[ChemLink,bool]: ...
    def path(self, code: str = ...) -> str: ...
    def read_monomer_cif(self, arg0: str) -> None: ...
    def read_monomer_lib(self, arg0: str, arg1: list[str]) -> bool: ...
    @property
    def links(self) -> ChemLinkMap: ...
    @property
    def modifications(self) -> ChemModMap: ...
    @property
    def monomer_dir(self) -> str: ...
    @property
    def monomers(self) -> ChemCompMap: ...

class Mtz:
    class Batch:
        number: int
        title: str
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        @property
        def axes(self) -> list[str]: ...
        @property
        def dataset_id(self) -> int: ...
        @property
        def floats(self) -> list[float]: ...
        @property
        def ints(self) -> list[int]: ...

    class Column:
        dataset_id: int
        idx: int
        label: str
        max_value: float
        min_value: float
        source: str
        type: str
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        def is_integer(self) -> bool: ...
        def __getitem__(self, index: int) -> float: ...
        def __iter__(self) -> Iterator[Any]: ...
        def __len__(self) -> int: ...
        @property
        def array(self) -> npt.NDArray[np.float32]: ...
        @property
        def dataset(self) -> Mtz.Dataset: ...

    class Dataset:
        cell: UnitCell
        crystal_name: str
        dataset_name: str
        id: int
        project_name: str
        wavelength: float
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    appended_text: str
    batches: MtzBatches
    cell: UnitCell
    columns: MtzColumns
    datasets: MtzDatasets
    history: list[str]
    max_1_d2: float
    min_1_d2: float
    nreflections: int
    sort_order: list[int]
    spacegroup: SpaceGroup
    title: str
    valm: float
    def __init__(self, with_base: bool = ...) -> None: ...
    def add_column(self, label: str, type: str, dataset_id: int = ..., pos: int = ..., expand_data: bool = ...) -> Mtz.Column: ...
    def add_dataset(self, name: str) -> Mtz.Dataset: ...
    def column_labels(self) -> list[str]: ...
    def column_with_label(self, label: str, dataset: Mtz.Dataset = ...) -> Mtz.Column: ...
    def columns_with_type(self, type: str) -> MtzColumnRefs: ...
    def copy_column(self, dest_idx: int, src_col: Mtz.Column, trailing_cols: list[str] = ...) -> Mtz.Column: ...
    def count(self, label: str) -> int: ...
    def data_fits_into(self, size: list[int]) -> bool: ...
    def dataset(self, id: int) -> Mtz.Dataset: ...
    def ensure_asu(self, tnt_asu: bool = ...) -> None: ...
    def get_cell(self, dataset: int = ...) -> UnitCell: ...
    def get_f_phi(self, f: str, phi: str, as_is: bool = ...) -> ComplexAsuData: ...
    def get_f_phi_on_grid(self, f: str, phi: str, size: list[int], half_l: bool = ..., order: AxisOrder = ...) -> ReciprocalComplexGrid: ...
    def get_float(self, col: str, as_is: bool = ...) -> FloatAsuData: ...
    def get_int(self, col: str, as_is: bool = ...) -> IntAsuData: ...
    def get_size_for_hkl(self, min_size: list[int] = ..., sample_rate: float = ...) -> list[int]: ...
    def get_value_on_grid(self, label: str, size: list[int], half_l: bool = ..., order: AxisOrder = ...) -> ReciprocalFloatGrid: ...
    def get_value_sigma(self, f: str, sigma: str, as_is: bool = ...) -> ValueSigmaAsuData: ...
    def make_1_d2_array(self, dataset: int = ...) -> npt.NDArray[np.float32]: ...
    def make_d_array(self, dataset: int = ...) -> npt.NDArray[np.float32]: ...
    def make_miller_array(self) -> npt.NDArray[np.int32]: ...
    def reindex(self, op: Op) -> str: ...
    def remove_column(self, index: int) -> None: ...
    def replace_column(self, dest_idx: int, src_col: Mtz.Column, trailing_cols: list[str] = ...) -> Mtz.Column: ...
    def resolution_high(self) -> float: ...
    def resolution_low(self) -> float: ...
    def rfree_column(self) -> Mtz.Column: ...
    def set_cell_for_all(self, arg0: UnitCell) -> None: ...
    @overload
    def set_data(self, asu_data: ComplexAsuData) -> None: ...
    @overload
    def set_data(self, asu_data: FloatAsuData) -> None: ...
    @overload
    def set_data(self, array: npt.NDArray[np.float32]) -> None: ...
    def sort(self, use_first: int = ...) -> bool: ...
    def switch_to_asu_hkl(self) -> bool: ...
    def switch_to_original_hkl(self) -> bool: ...
    def transform_f_phi_to_map(self, f: str, phi: str, min_size: list[int] = ..., exact_size: list[int] = ..., sample_rate: float = ..., order: AxisOrder = ...) -> FloatGrid: ...
    def update_reso(self) -> None: ...
    def write_to_file(self, path: str) -> None: ...
    @property
    def array(self) -> npt.NDArray[np.float32]: ...
    @property
    def nsymop(self) -> int: ...
    @property
    def spacegroup_name(self) -> str: ...
    @property
    def spacegroup_number(self) -> int: ...

class MtzBatches:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: MtzBatches) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Mtz.Batch) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: MtzBatches) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Mtz.Batch) -> None: ...
    @overload
    def pop(self) -> Mtz.Batch: ...
    @overload
    def pop(self, i: int) -> Mtz.Batch: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> MtzBatches: ...
    @overload
    def __getitem__(self, arg0: int) -> Mtz.Batch: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Mtz.Batch) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: MtzBatches) -> None: ...

class MtzColumnRefs:
    __hash__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: MtzColumnRefs) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Mtz.Column) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: Mtz.Column) -> int: ...
    @overload
    def extend(self, L: MtzColumnRefs) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Mtz.Column) -> None: ...
    @overload
    def pop(self) -> Mtz.Column: ...
    @overload
    def pop(self, i: int) -> Mtz.Column: ...
    def remove(self, x: Mtz.Column) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: Mtz.Column) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    # def __eq__(self, arg0: MtzColumnRefs) -> bool: ...
    @overload
    def __getitem__(self, s: slice) -> MtzColumnRefs: ...
    @overload
    def __getitem__(self, arg0: int) -> Mtz.Column: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    # def __ne__(self, arg0: MtzColumnRefs) -> bool: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Mtz.Column) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: MtzColumnRefs) -> None: ...

class MtzColumns:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: MtzColumns) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Mtz.Column) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: MtzColumns) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Mtz.Column) -> None: ...
    @overload
    def pop(self) -> Mtz.Column: ...
    @overload
    def pop(self, i: int) -> Mtz.Column: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> MtzColumns: ...
    @overload
    def __getitem__(self, arg0: int) -> Mtz.Column: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Mtz.Column) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: MtzColumns) -> None: ...

class MtzDatasets:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: MtzDatasets) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Mtz.Dataset) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: MtzDatasets) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Mtz.Dataset) -> None: ...
    @overload
    def pop(self) -> Mtz.Dataset: ...
    @overload
    def pop(self, i: int) -> Mtz.Dataset: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> MtzDatasets: ...
    @overload
    def __getitem__(self, arg0: int) -> Mtz.Dataset: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Mtz.Dataset) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: MtzDatasets) -> None: ...

class NcsOp:
    given: bool
    id: str
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, tr: Transform, id: str = ..., given: bool = ...) -> None: ...
    def apply(self, arg0: Position) -> Position: ...
    @property
    def tr(self) -> Transform: ...

class NcsOpList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: NcsOpList) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: NcsOp) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: NcsOpList) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: NcsOp) -> None: ...
    @overload
    def pop(self) -> NcsOp: ...
    @overload
    def pop(self, i: int) -> NcsOp: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> NcsOpList: ...
    @overload
    def __getitem__(self, arg0: int) -> NcsOp: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: NcsOp) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: NcsOpList) -> None: ...

class NearestImage:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def dist(self) -> float: ...
    def symmetry_code(self, underscore: bool = ...) -> str: ...
    @property
    def pbc_shift(self) -> tuple[int, int, int]: ...
    @property
    def sym_idx(self) -> int: ...

class NeighborSearch:
    class Mark:
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        def pos(self) -> Position: ...
        def to_cra(self, arg0: Model) -> CRA: ...
        def to_site(self, arg0: SmallStructure) -> SmallStructure.Site: ...
        @property
        def altloc(self) -> str: ...
        @property
        def atom_idx(self) -> int: ...
        @property
        def chain_idx(self) -> int: ...
        @property
        def element(self) -> Element: ...
        @property
        def image_idx(self) -> int: ...
        @property
        def residue_idx(self) -> int: ...
        @property
        def x(self) -> float: ...
        @property
        def y(self) -> float: ...
        @property
        def z(self) -> float: ...
    @overload
    def __init__(self, model: Model, cell: UnitCell, max_radius: float) -> None: ...
    @overload
    def __init__(self, st: Structure, max_radius: float, model_index: int = ...) -> None: ...
    @overload
    def __init__(self, small_structure: SmallStructure, max_radius: float) -> None: ...
    def add_atom(self, atom: Atom, n_ch: int, n_res: int, n_atom: int) -> None: ...
    def add_chain(self, chain: Chain, include_h: bool = ...) -> None: ...
    def dist(self, arg0: Position, arg1: Position) -> float: ...
    def find_atoms(self, pos: Position, alt: str = ..., radius: float = ...) -> VectorMarkPtr: ...
    def find_nearest_atom(self, arg0: Position) -> NeighborSearch.Mark: ...
    def find_neighbors(self, atom: Atom, min_dist: float = ..., max_dist: float = ...) -> VectorMarkPtr: ...
    def find_site_neighbors(self, atom: SmallStructure.Site, min_dist: float = ..., max_dist: float = ...) -> VectorMarkPtr: ...
    def get_image_transformation(self, arg0: int) -> FTransform: ...
    def populate(self, include_h: bool = ...) -> NeighborSearch: ...
    @property
    def grid_cell(self) -> UnitCell: ...
    @property
    def radius_specified(self) -> float: ...

class Neutron92:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def calculate_density_iso(self, r2: float, B: float) -> float: ...
    def calculate_sf(self, stol2: float) -> float: ...
    def get_coefs(self) -> list[float]: ...

class Op:
    DEN: ClassVar[int] = ...  # read-only
    rot: list[list[int]]
    tran: list[int]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def apply_to_hkl(self, hkl: list[int]) -> list[int]: ...
    def apply_to_xyz(self, xyz: list[float]) -> list[float]: ...
    def combine(self, b: Op) -> Op: ...
    def det_rot(self) -> int: ...
    def float_seitz(self) -> list[list[float]]: ...
    def inverse(self) -> Op: ...
    def phase_shift(self, hkl: list[int]) -> float: ...
    def rot_type(self) -> int: ...
    def seitz(self) -> list[list[int]]: ...
    def translated(self, a: list[int]) -> Op: ...
    def transposed_rot(self) -> list[list[int]]: ...
    def triplet(self, style: str = ...) -> str: ...
    def wrap(self) -> Op: ...
    def __copy__(self) -> Op: ...
    def __deepcopy__(self, memo: dict[Any, Any]) -> Op: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    @overload
    def __mul__(self, arg0: Op) -> Op: ...
    @overload
    def __mul__(self, arg0: str) -> Op: ...
    def __rmul__(self, arg0: str) -> Op: ...

class PolymerType:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    CyclicPseudoPeptide: ClassVar[PolymerType] = ...
    Dna: ClassVar[PolymerType] = ...
    DnaRnaHybrid: ClassVar[PolymerType] = ...
    Other: ClassVar[PolymerType] = ...
    PeptideD: ClassVar[PolymerType] = ...
    PeptideL: ClassVar[PolymerType] = ...
    Pna: ClassVar[PolymerType] = ...
    Rna: ClassVar[PolymerType] = ...
    SaccharideD: ClassVar[PolymerType] = ...
    SaccharideL: ClassVar[PolymerType] = ...
    Unknown: ClassVar[PolymerType] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Position(Vec3):
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...
    @overload
    def __init__(self, arg0: Vec3) -> None: ...
    def dist(self, arg0: Position) -> float: ...
    def __add__(self, arg0: Vec3) -> Position: ...
    def __iadd__(self, arg0: Vec3) -> Position: ...
    def __imul__(self, arg0: float) -> Position: ...
    def __isub__(self, arg0: Position) -> Position: ... # type: ignore[override]
    def __itruediv__(self, arg0: float) -> Position: ...
    def __mul__(self, arg0: float) -> Position: ...
    def __neg__(self) -> Position: ...
    def __rmul__(self, arg0: float) -> Position: ...
    def __sub__(self, arg0: Position) -> Position: ... # type: ignore[override]
    def __truediv__(self, arg0: float) -> Position: ...

class PositionBox:
    maximum: Position
    minimum: Position
    def __init__(self) -> None: ...
    def add_margin(self, arg0: float) -> None: ...
    def extend(self, arg0: Position) -> None: ...
    def get_size(self) -> Position: ...

class ReciprocalAsu:
    def __init__(self, arg0: SpaceGroup, tnt: bool = ...) -> None: ...
    def condition_str(self) -> str: ...
    def is_in(self, hkl: list[int]) -> bool: ...
    def to_asu(self, hkl: list[int], group_ops: GroupOps) -> tuple[list[int],int]: ...

class ReciprocalComplexGrid(ComplexGridBase):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, nx: int, ny: int, nz: int) -> None: ...
    @overload
    def __init__(self, arg0: npt.NDArray[np.complex64], cell: UnitCell = ..., spacegroup: SpaceGroup = ...) -> None: ...
    def calculate_1_d2(self, arg0: ComplexGridBase.Point) -> float: ...
    def calculate_d(self, arg0: ComplexGridBase.Point) -> float: ...
    def get_value(self, arg0: int, arg1: int, arg2: int) -> complex: ...
    def get_value_by_hkl(self, hkl: npt.NDArray[np.int32], unblur: float = ..., mott_bethe: bool = ..., mott_bethe_000: complex = ...) -> npt.NDArray[np.complex64]: ...
    def get_value_or_zero(self, arg0: int, arg1: int, arg2: int) -> complex: ...
    def prepare_asu_data(self, dmin: float = ..., unblur: float = ..., with_000: bool = ..., with_sys_abs: bool = ..., mott_bethe: bool = ...) -> ComplexAsuData: ...
    def set_value(self, arg0: int, arg1: int, arg2: int, arg3: complex) -> None: ...
    def to_hkl(self, arg0: ComplexGridBase.Point) -> list[int]: ...
    @property
    def half_l(self) -> bool: ...

class ReciprocalFloatGrid(FloatGridBase):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, nx: int, ny: int, nz: int) -> None: ...
    @overload
    def __init__(self, arg0: npt.NDArray[np.float32], cell: UnitCell = ..., spacegroup: SpaceGroup = ...) -> None: ...
    def calculate_1_d2(self, arg0: FloatGridBase.Point) -> float: ...
    def calculate_d(self, arg0: FloatGridBase.Point) -> float: ...
    def get_value(self, arg0: int, arg1: int, arg2: int) -> float: ...
    def get_value_by_hkl(self, hkl: npt.NDArray[np.int32], unblur: float = ..., mott_bethe: bool = ..., mott_bethe_000: float = ...) -> npt.NDArray[np.float32]: ...
    def get_value_or_zero(self, arg0: int, arg1: int, arg2: int) -> float: ...
    def prepare_asu_data(self, dmin: float = ..., unblur: float = ..., with_000: bool = ..., with_sys_abs: bool = ..., mott_bethe: bool = ...) -> FloatAsuData: ...
    def set_value(self, arg0: int, arg1: int, arg2: int, arg3: float) -> None: ...
    def to_hkl(self, arg0: FloatGridBase.Point) -> list[int]: ...
    @property
    def half_l(self) -> bool: ...

class ReciprocalInt8Grid(Int8GridBase):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, nx: int, ny: int, nz: int) -> None: ...
    @overload
    def __init__(self, arg0: npt.NDArray[np.int8], cell: UnitCell = ..., spacegroup: SpaceGroup = ...) -> None: ...
    def calculate_1_d2(self, arg0: Int8GridBase.Point) -> float: ...
    def calculate_d(self, arg0: Int8GridBase.Point) -> float: ...
    def get_value(self, arg0: int, arg1: int, arg2: int) -> int: ...
    def get_value_by_hkl(self, hkl: npt.NDArray[np.int32], unblur: float = ..., mott_bethe: bool = ..., mott_bethe_000: int = ...) -> npt.NDArray[np.int32]: ...
    def get_value_or_zero(self, arg0: int, arg1: int, arg2: int) -> int: ...
    def prepare_asu_data(self, dmin: float = ..., unblur: float = ..., with_000: bool = ..., with_sys_abs: bool = ..., mott_bethe: bool = ...) -> IntAsuData: ...
    def set_value(self, arg0: int, arg1: int, arg2: int, arg3: int) -> None: ...
    def to_hkl(self, arg0: Int8GridBase.Point) -> list[int]: ...
    @property
    def half_l(self) -> bool: ...

class ReflnBlock:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def column_labels(self) -> list[str]: ...
    def data_fits_into(self, size: list[int]) -> bool: ...
    def get_f_phi(self, f: str, phi: str, as_is: bool = ...) -> ComplexAsuData: ...
    def get_f_phi_on_grid(self, f: str, phi: str, size: list[int], half_l: bool = ..., order: AxisOrder = ...) -> ReciprocalComplexGrid: ...
    def get_float(self, col: str, as_is: bool = ...) -> FloatAsuData: ...
    def get_int(self, col: str, as_is: bool = ...) -> IntAsuData: ...
    def get_size_for_hkl(self, min_size: list[int] = ..., sample_rate: float = ...) -> list[int]: ...
    def get_value_on_grid(self, column: str, size: list[int], half_l: bool = ..., order: AxisOrder = ...) -> ReciprocalFloatGrid: ...
    def get_value_sigma(self, f: str, sigma: str, as_is: bool = ...) -> ValueSigmaAsuData: ...
    def is_unmerged(self) -> bool: ...
    def make_1_d2_array(self) -> npt.NDArray[np.float64]: ...
    def make_d_array(self) -> npt.NDArray[np.float64]: ...
    def make_float_array(self, tag: str, null: float = ...) -> npt.NDArray[np.float64] | list[float]: ...
    def make_int_array(self, tag: str, null: int) -> npt.NDArray[np.int32]: ...
    def make_miller_array(self) -> npt.NDArray[np.int32]: ...
    def transform_f_phi_to_map(self, f: str, phi: str, min_size: list[int] = ..., exact_size: list[int] = ..., sample_rate: float = ..., order: AxisOrder = ...) -> FloatGrid: ...
    def use_unmerged(self, arg0: bool) -> None: ...
    def __bool__(self) -> bool: ...
    @property
    def block(self) -> Block: ...
    @property
    def cell(self) -> UnitCell: ...
    @property
    def entry_id(self) -> str: ...
    @property
    def spacegroup(self) -> SpaceGroup: ...
    @property
    def wavelength(self) -> float: ...

class ReflnBlocks:
    def __init__(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __getitem__(self, arg0: int) -> ReflnBlock: ...
    def __iter__(self) -> Iterator[ReflnBlock]: ...
    def __len__(self) -> int: ...

class Residue(ResidueId):
    entity_type: EntityType
    flag: str
    het_flag: str
    label_seq: int | None
    subchain: str
    def __init__(self) -> None: ...
    def add_atom(self, atom: Atom, pos: int = ...) -> Atom: ...
    def clone(self) -> Residue: ...
    def find_atom(self, name: str, altloc: str, el: Element = ...) -> Atom: ...
    def first_conformer(self) -> FirstConformerAtoms: ...
    def get_ca(self) -> Atom: ...
    def get_p(self) -> Atom: ...
    def is_water(self) -> bool: ...
    def remove_atom(self, name: str, altloc: str, el: Element = ...) -> None: ...
    def remove_hydrogens(self) -> None: ...
    def sole_atom(self, arg0: str) -> Atom: ...
    def trim_to_alanine(self) -> bool: ...
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __delitem__(self, index: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, index: int) -> Atom: ...
    @overload
    def __getitem__(self, name: str) -> AtomGroup: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @property
    def entity_id(self) -> str: ...
    @property
    def sifts_unp(self) -> tuple[str, float, float]: ...

class ResidueGroup(ResidueSpan):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __delitem__(self, name: str) -> None: ... # type: ignore[override]
    @overload
    def __getitem__(self, index: int) -> Residue: ...
    @overload
    def __getitem__(self, name: str) -> ResidueGroup: ...

class ResidueId:
    __hash__: Any = ...
    name: str
    segment: str
    seqid: SeqId
    def __init__(self) -> None: ...
    def __eq__(self, arg0: ResidueId) -> bool: ... # type: ignore[override]
    def __getstate__(self) -> tuple[ResidueId, str, str]: ...
    def __setstate__(self, arg0: tuple[ResidueId, str, str]) -> None: ...

class ResidueInfo:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def fasta_code(self) -> str: ...
    def found(self) -> bool: ...
    def is_amino_acid(self) -> bool: ...
    def is_nucleic_acid(self) -> bool: ...
    def is_standard(self) -> bool: ...
    def is_water(self) -> bool: ...
    @property
    def hydrogen_count(self) -> int: ...
    @property
    def kind(self) -> ResidueInfoKind: ...
    @property
    def one_letter_code(self) -> str: ...
    @property
    def weight(self) -> float: ...

class ResidueInfoKind:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    AA: ClassVar[ResidueInfoKind] = ...
    AAD: ClassVar[ResidueInfoKind] = ...
    BUF: ClassVar[ResidueInfoKind] = ...
    DNA: ClassVar[ResidueInfoKind] = ...
    ELS: ClassVar[ResidueInfoKind] = ...
    HOH: ClassVar[ResidueInfoKind] = ...
    KET: ClassVar[ResidueInfoKind] = ...
    MAA: ClassVar[ResidueInfoKind] = ...
    PAA: ClassVar[ResidueInfoKind] = ...
    PYR: ClassVar[ResidueInfoKind] = ...
    RNA: ClassVar[ResidueInfoKind] = ...
    UNKNOWN: ClassVar[ResidueInfoKind] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ResidueSpan:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def add_residue(self, residue: Residue, pos: int = ...) -> Residue: ...
    def auth_seq_id_to_label(self, arg0: SeqId) -> int | None: ...
    def check_polymer_type(self) -> PolymerType: ...
    def first_conformer(self) -> FirstConformerResSpan: ...
    def label_seq_id_to_auth(self, arg0: int | None) -> SeqId: ...
    def length(self) -> int: ...
    def make_one_letter_sequence(self) -> str: ...
    def residue_groups(self) -> ResidueSpanGroups: ...
    def subchain_id(self) -> str: ...
    def transform_pos_and_adp(self, arg0: Transform) -> None: ...
    def __bool__(self) -> bool: ...
    def __delitem__(self, index: int) -> None: ...
    @overload
    def __getitem__(self, index: int) -> Residue: ...
    @overload
    def __getitem__(self, pdb_seqid: str) -> ResidueGroup: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...

class ResidueSpanGroups:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class Restraints:
    class Angle:
        esd: float
        id1: Restraints.AtomId
        id2: Restraints.AtomId
        id3: Restraints.AtomId
        value: float
        def __init__(self) -> None: ...

    class AtomId:
        atom: str
        comp: int
        @overload
        def __init__(self, arg0: int, arg1: str) -> None: ...
        @overload
        def __init__(self, arg0: str) -> None: ...
        def get_from(self, res1: Residue, res2: Residue, altloc: str) -> Atom: ...

    class Bond:
        aromatic: bool
        esd: float
        esd_nucleus: float
        id1: Restraints.AtomId
        id2: Restraints.AtomId
        type: BondType
        value: float
        value_nucleus: float
        def __init__(self) -> None: ...
        def lexicographic_str(self) -> str: ...

    class Chirality:
        id1: Restraints.AtomId
        id2: Restraints.AtomId
        id3: Restraints.AtomId
        id_ctr: Restraints.AtomId
        sign: ChiralityType
        def __init__(self) -> None: ...
        def is_wrong(self, arg0: float) -> bool: ...

    class DistanceOf:
        __members__: ClassVar[dict[Any, Any]] = ...  # read-only
        ElectronCloud: ClassVar[Restraints.DistanceOf] = ...
        Nucleus: ClassVar[Restraints.DistanceOf] = ...
        __entries: ClassVar[dict[Any, Any]] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Plane:
        esd: float
        ids: list[Restraints.AtomId]
        label: str
        def __init__(self) -> None: ...

    class Torsion:
        esd: float
        id1: Restraints.AtomId
        id2: Restraints.AtomId
        id3: Restraints.AtomId
        id4: Restraints.AtomId
        label: str
        period: int
        value: float
        def __init__(self) -> None: ...
    angles: RestraintsAngles
    bonds: RestraintsBonds
    chirs: RestraintsChirs
    planes: RestraintsPlanes
    torsions: RestraintsTorsions
    def __init__(self) -> None: ...
    def chiral_abs_volume(self, arg0: Restraints.Chirality) -> float: ...
    def empty(self) -> bool: ...
    def find_shortest_path(self, arg0: Restraints.AtomId, arg1: Restraints.AtomId, arg2: list[Restraints.AtomId]) -> list[Restraints.AtomId]: ...
    @overload
    def get_bond(self, arg0: Restraints.AtomId, arg1: Restraints.AtomId) -> Restraints.Bond: ...
    @overload
    def get_bond(self, arg0: str, arg1: str) -> Restraints.Bond: ...

class RestraintsAngles:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: RestraintsAngles) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Restraints.Angle) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: RestraintsAngles) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Restraints.Angle) -> None: ...
    @overload
    def pop(self) -> Restraints.Angle: ...
    @overload
    def pop(self, i: int) -> Restraints.Angle: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> RestraintsAngles: ...
    @overload
    def __getitem__(self, arg0: int) -> Restraints.Angle: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Restraints.Angle) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: RestraintsAngles) -> None: ...

class RestraintsBonds:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: RestraintsBonds) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Restraints.Bond) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: RestraintsBonds) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Restraints.Bond) -> None: ...
    @overload
    def pop(self) -> Restraints.Bond: ...
    @overload
    def pop(self, i: int) -> Restraints.Bond: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> RestraintsBonds: ...
    @overload
    def __getitem__(self, arg0: int) -> Restraints.Bond: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Restraints.Bond) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: RestraintsBonds) -> None: ...

class RestraintsChirs:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: RestraintsChirs) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Restraints.Chirality) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: RestraintsChirs) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Restraints.Chirality) -> None: ...
    @overload
    def pop(self) -> Restraints.Chirality: ...
    @overload
    def pop(self, i: int) -> Restraints.Chirality: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> RestraintsChirs: ...
    @overload
    def __getitem__(self, arg0: int) -> Restraints.Chirality: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Restraints.Chirality) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: RestraintsChirs) -> None: ...

class RestraintsPlanes:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: RestraintsPlanes) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Restraints.Plane) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: RestraintsPlanes) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Restraints.Plane) -> None: ...
    @overload
    def pop(self) -> Restraints.Plane: ...
    @overload
    def pop(self, i: int) -> Restraints.Plane: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> RestraintsPlanes: ...
    @overload
    def __getitem__(self, arg0: int) -> Restraints.Plane: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Restraints.Plane) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: RestraintsPlanes) -> None: ...

class RestraintsTorsions:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: RestraintsTorsions) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Restraints.Torsion) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: RestraintsTorsions) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Restraints.Torsion) -> None: ...
    @overload
    def pop(self) -> Restraints.Torsion: ...
    @overload
    def pop(self, i: int) -> Restraints.Torsion: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> RestraintsTorsions: ...
    @overload
    def __getitem__(self, arg0: int) -> Restraints.Torsion: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Restraints.Torsion) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: RestraintsTorsions) -> None: ...

class SMat33d:
    u11: float
    u12: float
    u13: float
    u22: float
    u23: float
    u33: float
    def __init__(self, u11: float, u22: float, u33: float, u12: float, u13: float, u23: float) -> None: ...
    def added_kI(self, arg0: float) -> SMat33d: ...
    def as_mat33(self) -> Mat33: ...
    def calculate_eigenvalues(self) -> list[float]: ...
    def determinant(self) -> float: ...
    def elements_pdb(self) -> list[float]: ...
    def elements_voigt(self) -> list[float]: ...
    def inverse(self) -> SMat33d: ...
    def multiply(self, arg0: Vec3) -> Vec3: ...
    def nonzero(self) -> bool: ...
    @overload
    def r_u_r(self, arg0: Vec3) -> float: ...
    @overload
    def r_u_r(self, arg0: npt.NDArray[np.int32]) -> npt.NDArray[np.float64]: ...
    def trace(self) -> float: ...
    def transformed_by(self, arg0: Mat33) -> SMat33d: ...
    def __add__(self, arg0: SMat33d) -> SMat33d: ...
    def __sub__(self, arg0: SMat33d) -> SMat33d: ...

class SMat33f:
    u11: float
    u12: float
    u13: float
    u22: float
    u23: float
    u33: float
    def __init__(self, u11: float, u22: float, u33: float, u12: float, u13: float, u23: float) -> None: ...
    def added_kI(self, arg0: float) -> SMat33f: ...
    def as_mat33(self) -> Mat33: ...
    def calculate_eigenvalues(self) -> list[float]: ...
    def determinant(self) -> float: ...
    def elements_pdb(self) -> list[float]: ...
    def elements_voigt(self) -> list[float]: ...
    def inverse(self) -> SMat33f: ...
    def multiply(self, arg0: Vec3) -> Vec3: ...
    def nonzero(self) -> bool: ...
    @overload
    def r_u_r(self, arg0: Vec3) -> float: ...
    @overload
    def r_u_r(self, arg0: npt.NDArray[np.int32]) -> npt.NDArray[np.float32]: ...
    def trace(self) -> float: ...
    def transformed_by(self, arg0: Mat33) -> SMat33f: ...
    def __add__(self, arg0: SMat33f) -> SMat33f: ...
    def __sub__(self, arg0: SMat33f) -> SMat33f: ...

class Scaling:
    b_overall: SMat33d
    b_sol: float
    cell: UnitCell
    crystal_system: CrystalSystem
    k_overall: float
    k_sol: float
    use_solvent: bool
    def __init__(self, arg0: UnitCell, arg1: SpaceGroup) -> None: ...
    def fit_isotropic_b_approximately(self) -> None: ...
    def fit_parameters(self) -> None: ...
    @overload
    def get_overall_scale_factor(self, hkl: list[int]) -> float: ...
    @overload
    def get_overall_scale_factor(self, arg0: npt.NDArray[np.int32]) -> npt.NDArray[np.float64]: ...
    def get_solvent_scale(self, stol2: npt.NDArray[np.float64]) -> object: ...
    def prepare_points(self, calc: ComplexAsuData, obs: ValueSigmaAsuData, mask: ComplexAsuData = ...) -> None: ...
    def scale_data(self, asu_data: ComplexAsuData, mask_data: ComplexAsuData = ...) -> None: ...
    def scale_value(self, hkl: list[int], f_value: complex, mask_value: complex) -> complex: ...

class Selection:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def atoms(self, arg0: Residue) -> SelectionAtomsProxy: ...
    def chains(self, arg0: Model) -> SelectionChainsProxy: ...
    def copy_model_selection(self, arg0: Model) -> Model: ...
    def copy_structure_selection(self, arg0: Structure) -> Structure: ...
    def first(self, arg0: Structure) -> tuple[Model,CRA]: ...
    def first_in_model(self, arg0: Model) -> CRA: ...
    def models(self, arg0: Structure) -> SelectionModelsProxy: ...
    @overload
    def remove_not_selected(self, arg0: Structure) -> None: ...
    @overload
    def remove_not_selected(self, arg0: Model) -> None: ...
    @overload
    def remove_selected(self, arg0: Structure) -> None: ...
    @overload
    def remove_selected(self, arg0: Model) -> None: ...
    def residues(self, arg0: Chain) -> SelectionResiduesProxy: ...
    def set_atom_flags(self, arg0: str) -> Selection: ...
    def set_residue_flags(self, arg0: str) -> Selection: ...
    def str(self) -> str: ...

class SelectionAtomsProxy:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class SelectionChainsProxy:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class SelectionModelsProxy:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class SelectionResiduesProxy:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...

class SellingVector:
    @overload
    def __init__(self, arg0: list[float]) -> None: ...
    @overload
    def __init__(self, arg0: UnitCell, arg1: SpaceGroup) -> None: ...
    def cell_parameters(self) -> tuple[float, float, float, float, float, float]: ...
    def get_cell(self) -> UnitCell: ...
    def gruber(self) -> GruberVector: ...
    def is_reduced(self, epsilon: float = ...) -> bool: ...
    def reduce(self, epsilon: float = ..., iteration_limit: int = ...) -> int: ...
    def reduce_step(self, epsilon: float = ...) -> bool: ...
    def sort(self, epsilon: float = ...) -> None: ...
    def sum_b_squared(self) -> float: ...
    @property
    def parameters(self) -> tuple[float, float, float, float, float, float]: ...

class SeqId:
    __hash__: Any = ...
    icode: str
    num: int | None
    @overload
    def __init__(self, arg0: int, arg1: str) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: SeqId) -> bool: ... # type: ignore[override]
    def __getstate__(self) -> tuple[int, str]: ...
    def __lt__(self, arg0: SeqId) -> bool: ...
    def __setstate__(self, arg0: tuple[int, str]) -> None: ...

class Sheet:
    class Strand:
        end: AtomAddress
        hbond_atom1: AtomAddress
        hbond_atom2: AtomAddress
        name: str
        sense: int
        start: AtomAddress
        def __init__(self) -> None: ...

    class StrandList:
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: Sheet.StrandList) -> None: ...
        @overload
        def __init__(self, arg0: Iterable[Any]) -> None: ...
        def append(self, x: Sheet.Strand) -> None: ...
        def clear(self) -> None: ...
        @overload
        def extend(self, L: Sheet.StrandList) -> None: ...
        @overload
        def extend(self, L: Iterable[Any]) -> None: ...
        def insert(self, i: int, x: Sheet.Strand) -> None: ...
        @overload
        def pop(self) -> Sheet.Strand: ...
        @overload
        def pop(self, i: int) -> Sheet.Strand: ...
        def __bool__(self) -> bool: ...
        @overload
        def __delitem__(self, arg0: int) -> None: ...
        @overload
        def __delitem__(self, arg0: slice) -> None: ...
        @overload
        def __getitem__(self, s: slice) -> Sheet.StrandList: ...
        @overload
        def __getitem__(self, arg0: int) -> Sheet.Strand: ...
        def __iter__(self) -> Iterator[Any]: ...
        def __len__(self) -> int: ...
        @overload
        def __setitem__(self, arg0: int, arg1: Sheet.Strand) -> None: ...
        @overload
        def __setitem__(self, arg0: slice, arg1: Sheet.StrandList) -> None: ...
    name: str
    strands: Sheet.StrandList
    def __init__(self, arg0: str) -> None: ...

class SheetList:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: SheetList) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Sheet) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: SheetList) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Sheet) -> None: ...
    @overload
    def pop(self) -> Sheet: ...
    @overload
    def pop(self, i: int) -> Sheet: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> SheetList: ...
    @overload
    def __getitem__(self, arg0: int) -> Sheet: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Sheet) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: SheetList) -> None: ...

class SmallStructure:
    class AtomType:
        dispersion_imag: float
        dispersion_real: float
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        @property
        def element(self) -> Element: ...
        @property
        def symbol(self) -> str: ...

    class Site:
        aniso: SMat33d
        charge: int
        disorder_group: int
        element: Element
        fract: Fractional
        label: str
        occ: float
        type_symbol: str
        u_iso: float
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: Atom, arg1: UnitCell) -> None: ...
        def orth(self, arg0: UnitCell) -> Position: ...

    class SiteList:
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: SmallStructure.SiteList) -> None: ...
        @overload
        def __init__(self, arg0: Iterable[Any]) -> None: ...
        def append(self, x: SmallStructure.Site) -> None: ...
        def clear(self) -> None: ...
        @overload
        def extend(self, L: SmallStructure.SiteList) -> None: ...
        @overload
        def extend(self, L: Iterable[Any]) -> None: ...
        def insert(self, i: int, x: SmallStructure.Site) -> None: ...
        @overload
        def pop(self) -> SmallStructure.Site: ...
        @overload
        def pop(self, i: int) -> SmallStructure.Site: ...
        def __bool__(self) -> bool: ...
        @overload
        def __delitem__(self, arg0: int) -> None: ...
        @overload
        def __delitem__(self, arg0: slice) -> None: ...
        @overload
        def __getitem__(self, s: slice) -> SmallStructure.SiteList: ...
        @overload
        def __getitem__(self, arg0: int) -> SmallStructure.Site: ...
        def __iter__(self) -> Iterator[Any]: ...
        def __len__(self) -> int: ...
        @overload
        def __setitem__(self, arg0: int, arg1: SmallStructure.Site) -> None: ...
        @overload
        def __setitem__(self, arg0: slice, arg1: SmallStructure.SiteList) -> None: ...
    cell: UnitCell
    name: str
    spacegroup_hm: str
    wavelength: float
    def __init__(self) -> None: ...
    def add_site(self, arg0: SmallStructure.Site) -> None: ...
    def change_occupancies_to_crystallographic(self, max_dist: float = ...) -> None: ...
    def find_spacegroup(self) -> SpaceGroup: ...
    def get_all_unit_cell_sites(self) -> SmallStructure.SiteList: ...
    def get_atom_type(self, arg0: str) -> SmallStructure.AtomType: ...
    def make_cif_block(self) -> Block: ...
    def remove_hydrogens(self) -> None: ...
    def setup_cell_images(self) -> None: ...
    @property
    def atom_types(self) -> list[SmallStructure.AtomType]: ...
    @property
    def sites(self) -> SmallStructure.SiteList: ...

class SolventMasker:
    atomic_radii_set: AtomicRadiiSet
    constant_r: float
    island_min_volume: float
    rprobe: float
    rshrink: float
    def __init__(self, choice: AtomicRadiiSet, constant_r: float = ...) -> None: ...
    def put_mask_on_float_grid(self, arg0: FloatGrid, arg1: Model) -> None: ...
    def put_mask_on_int8_grid(self, arg0: Int8Grid, arg1: Model) -> None: ...
    def set_radii(self, choice: AtomicRadiiSet, constant_r: float = ...) -> None: ...
    def set_to_zero(self, arg0: FloatGrid, arg1: Model) -> None: ...

class SpaceGroup:
    @overload
    def __init__(self, ccp4: int) -> None: ...
    @overload
    def __init__(self, hm: str) -> None: ...
    def centred_to_primitive(self) -> Op: ...
    def centring_type(self) -> str: ...
    def crystal_system(self) -> CrystalSystem: ...
    def crystal_system_str(self) -> str: ...
    def is_centrosymmetric(self) -> bool: ...
    def is_enantiomorphic(self) -> bool: ...
    def is_reference_setting(self) -> bool: ...
    def is_sohncke(self) -> bool: ...
    def is_symmorphic(self) -> bool: ...
    def laue_str(self) -> str: ...
    def operations(self) -> GroupOps: ...
    def point_group_hm(self) -> str: ...
    def short_name(self) -> str: ...
    def switch_to_asu(self, miller_array: npt.NDArray[np.int32]) -> None: ...
    def xhm(self) -> str: ...
    def __getstate__(self) -> str: ...
    def __setstate__(self, arg0: str) -> None: ...
    @property
    def basisop(self) -> Op: ...
    @property
    def ccp4(self) -> int: ...
    @property
    def ext(self) -> str: ...
    @property
    def hall(self) -> str: ...
    @property
    def hm(self) -> str: ...
    @property
    def number(self) -> int: ...
    @property
    def qualifier(self) -> str: ...

class Structure:
    assemblies: AssemblyList
    cell: UnitCell
    connections: ConnectionList
    entities: EntityList
    has_d_fraction: bool
    helices: HelixList
    info: InfoMap
    input_format: CoorFormat
    meta: Metadata
    name: str
    ncs: NcsOpList
    raw_remarks: list[str]
    resolution: float
    sheets: SheetList
    spacegroup_hm: str
    def __init__(self) -> None: ...
    def add_entity_types(self, overwrite: bool = ...) -> None: ...
    def add_model(self, model: Model, pos: int = ...) -> Model: ...
    def assign_cis_flags(self) -> None: ...
    def assign_label_seq_id(self, force: bool = ...) -> None: ...
    def assign_serial_numbers(self) -> None: ...
    def assign_subchains(self, force: bool = ..., fail_if_unknown: bool = ...) -> None: ...
    def calculate_box(self, margin: float = ...) -> PositionBox: ...
    def calculate_fractional_box(self, margin: float = ...) -> FractionalBox: ...
    def clone(self) -> Structure: ...
    def collapse_hd_mixture(self) -> None: ...
    def deduplicate_entities(self) -> None: ...
    def ensure_entities(self) -> None: ...
    def expand_hd_mixture(self) -> None: ...
    def expand_ncs(self, how: HowToNameCopiedChain) -> None: ...
    def find_connection(self, partner1: AtomAddress, partner2: AtomAddress) -> Connection: ...
    def find_connection_by_cra(self, arg0: CRA, arg1: CRA) -> Connection: ...
    def find_or_add_model(self, name: str) -> Model: ...
    def find_spacegroup(self) -> SpaceGroup: ...
    def get_entity(self, subchain: str) -> Entity: ...
    def get_entity_of(self, subchain: ResidueSpan) -> Entity: ...
    def make_minimal_pdb(self) -> str: ...
    def make_mmcif_block(self, groups: MmcifOutputGroups = ...) -> Block: ...
    def make_mmcif_document(self, groups: MmcifOutputGroups = ...) -> Document: ...
    def make_mmcif_headers(self) -> Block: ...
    def make_pdb_headers(self) -> str: ...
    def merge_chain_parts(self, min_sep: int = ...) -> None: ...
    def remove_alternative_conformations(self) -> None: ...
    def remove_empty_chains(self) -> None: ...
    def remove_hydrogens(self) -> None: ...
    def remove_ligands_and_waters(self) -> None: ...
    def remove_waters(self) -> None: ...
    def renumber_models(self) -> None: ...
    def setup_cell_images(self) -> None: ...
    def setup_entities(self) -> None: ...
    def shorten_chain_names(self) -> None: ...
    def transform_to_assembly(self, assembly_name: str, how: HowToNameCopiedChain) -> None: ...
    def update_mmcif_block(self, block: Block, groups: MmcifOutputGroups = ...) -> None: ...
    def write_minimal_pdb(self, path: str) -> None: ...
    def write_pdb(self, path: str, seqres_records: bool = ..., ssbond_records: bool = ..., link_records: bool = ..., cispep_records: bool = ..., ter_records: bool = ..., numbered_ter: bool = ..., ter_ignores_type: bool = ..., use_linkr: bool = ...) -> None: ...
    @overload
    def __delitem__(self, index: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(self, name: str) -> None: ...
    @overload
    def __getitem__(self, index: int) -> Model: ...
    @overload
    def __getitem__(self, name: str) -> Model: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: int, arg1: Model) -> None: ...

class StructureFactorCalculatorE:
    addends: Addends
    def __init__(self, arg0: UnitCell) -> None: ...
    def calculate_sf_from_model(self, arg0: Model, arg1: list[int]) -> complex: ...
    def calculate_sf_from_small_structure(self, arg0: SmallStructure, arg1: list[int]) -> complex: ...

class StructureFactorCalculatorN:
    addends: Addends
    def __init__(self, arg0: UnitCell) -> None: ...
    def calculate_sf_from_model(self, arg0: Model, arg1: list[int]) -> complex: ...
    def calculate_sf_from_small_structure(self, arg0: SmallStructure, arg1: list[int]) -> complex: ...

class StructureFactorCalculatorX:
    addends: Addends
    def __init__(self, arg0: UnitCell) -> None: ...
    def calculate_mb_z(self, model: Model, hkl: list[int], only_h: bool = ...) -> complex: ...
    def calculate_sf_from_model(self, arg0: Model, arg1: list[int]) -> complex: ...
    def calculate_sf_from_small_structure(self, arg0: SmallStructure, arg1: list[int]) -> complex: ...
    def mott_bethe_factor(self) -> float: ...

class SupResult:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @property
    def center1(self) -> Position: ...
    @property
    def center2(self) -> Position: ...
    @property
    def count(self) -> int: ...
    @property
    def rmsd(self) -> float: ...
    @property
    def transform(self) -> Transform: ...

class SupSelect:
    __members__: ClassVar[dict[Any, Any]] = ...  # read-only
    All: ClassVar[SupSelect] = ...
    CaP: ClassVar[SupSelect] = ...
    MainChain: ClassVar[SupSelect] = ...
    __entries: ClassVar[dict[Any, Any]] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Topo:
    class Angle:
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        def calculate(self) -> float: ...
        def calculate_z(self) -> float: ...
        @property
        def atoms(self) -> list[Atom]: ...
        @property
        def restr(self) -> Restraints.Angle: ...

    class Bond:
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        def calculate(self) -> float: ...
        def calculate_z(self) -> float: ...
        @property
        def atoms(self) -> list[Atom]: ...
        @property
        def restr(self) -> Restraints.Bond: ...

    class Chirality:
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        def calculate(self) -> float: ...
        def calculate_z(self, ideal_abs_vol: float, esd: float) -> float: ...
        def check(self) -> bool: ...
        @property
        def atoms(self) -> list[Atom]: ...
        @property
        def restr(self) -> Restraints.Chirality: ...

    class Link:
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        @property
        def alt1(self) -> str: ...
        @property
        def alt2(self) -> str: ...
        @property
        def link_id(self) -> str: ...
        @property
        def res1(self) -> Residue: ...
        @property
        def res2(self) -> Residue: ...

    class Plane:
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        def has(self, arg0: Atom) -> bool: ...
        @property
        def atoms(self) -> list[Atom]: ...
        @property
        def restr(self) -> Restraints.Plane: ...

    class Torsion:
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        def calculate(self) -> float: ...
        def calculate_z(self) -> float: ...
        @property
        def atoms(self) -> list[Atom]: ...
        @property
        def restr(self) -> Restraints.Torsion: ...
    def __init__(self) -> None: ...
    def adjust_hydrogen_distances(self, of: Restraints.DistanceOf, default_scale: float = ...) -> None: ...
    def first_bond_in_link(self, arg0: Topo.Link) -> Topo.Bond: ...
    def ideal_chiral_abs_volume(self, arg0: Topo.Chirality) -> float: ...
    def links_to_previous(self, arg0: Residue) -> TopoLinks: ...
    @property
    def angles(self) -> TopoAngles: ...
    @property
    def bonds(self) -> TopoBonds: ...
    @property
    def chirs(self) -> TopoChirs: ...
    @property
    def extras(self) -> TopoLinks: ...
    @property
    def planes(self) -> TopoPlanes: ...
    @property
    def torsions(self) -> TopoTorsions: ...

class TopoAngles:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TopoAngles) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Topo.Angle) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: TopoAngles) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Topo.Angle) -> None: ...
    @overload
    def pop(self) -> Topo.Angle: ...
    @overload
    def pop(self, i: int) -> Topo.Angle: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> TopoAngles: ...
    @overload
    def __getitem__(self, arg0: int) -> Topo.Angle: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Topo.Angle) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: TopoAngles) -> None: ...

class TopoBonds:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TopoBonds) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Topo.Bond) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: TopoBonds) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Topo.Bond) -> None: ...
    @overload
    def pop(self) -> Topo.Bond: ...
    @overload
    def pop(self, i: int) -> Topo.Bond: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> TopoBonds: ...
    @overload
    def __getitem__(self, arg0: int) -> Topo.Bond: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Topo.Bond) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: TopoBonds) -> None: ...

class TopoChirs:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TopoChirs) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Topo.Chirality) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: TopoChirs) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Topo.Chirality) -> None: ...
    @overload
    def pop(self) -> Topo.Chirality: ...
    @overload
    def pop(self, i: int) -> Topo.Chirality: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> TopoChirs: ...
    @overload
    def __getitem__(self, arg0: int) -> Topo.Chirality: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Topo.Chirality) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: TopoChirs) -> None: ...

class TopoLinks:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TopoLinks) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Topo.Link) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: TopoLinks) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Topo.Link) -> None: ...
    @overload
    def pop(self) -> Topo.Link: ...
    @overload
    def pop(self, i: int) -> Topo.Link: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> TopoLinks: ...
    @overload
    def __getitem__(self, arg0: int) -> Topo.Link: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Topo.Link) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: TopoLinks) -> None: ...

class TopoPlanes:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TopoPlanes) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Topo.Plane) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: TopoPlanes) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Topo.Plane) -> None: ...
    @overload
    def pop(self) -> Topo.Plane: ...
    @overload
    def pop(self, i: int) -> Topo.Plane: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> TopoPlanes: ...
    @overload
    def __getitem__(self, arg0: int) -> Topo.Plane: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Topo.Plane) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: TopoPlanes) -> None: ...

class TopoTorsions:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TopoTorsions) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: Topo.Torsion) -> None: ...
    def clear(self) -> None: ...
    @overload
    def extend(self, L: TopoTorsions) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: Topo.Torsion) -> None: ...
    @overload
    def pop(self) -> Topo.Torsion: ...
    @overload
    def pop(self, i: int) -> Topo.Torsion: ...
    def __bool__(self) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __getitem__(self, s: slice) -> TopoTorsions: ...
    @overload
    def __getitem__(self, arg0: int) -> Topo.Torsion: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Topo.Torsion) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: TopoTorsions) -> None: ...

class Transform:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mat33: Mat33, vec3: Vec3) -> None: ...
    def apply(self, arg0: Vec3) -> Vec3: ...
    def approx(self, other: Transform, epsilon: float) -> bool: ...
    def combine(self, arg0: Transform) -> Transform: ...
    def inverse(self) -> Transform: ...
    def is_identity(self) -> bool: ...
    def __matmul__(self, *args: Any, **kwargs: Any) -> Any: ...
    @property
    def mat(self) -> Mat33: ...
    @property
    def vec(self) -> Vec3: ...

class UnitCell:
    __hash__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a: float, b: float, c: float, alpha: float, beta: float, gamma: float) -> None: ...
    def approx(self, other: UnitCell, epsilon: float) -> bool: ...
    def calculate_1_d2(self, hkl: list[int]) -> float: ...
    def calculate_1_d2_array(self, arg0: npt.NDArray[np.int32]) -> npt.NDArray[np.float64]: ...
    def calculate_d(self, hkl: list[int]) -> float: ...
    def calculate_d_array(self, arg0: npt.NDArray[np.int32]) -> npt.NDArray[np.float64]: ...
    def calculate_u_eq(self, arg0: SMat33d) -> float: ...
    def changed_basis_backward(self, op: Op, set_images: bool) -> UnitCell: ...
    def changed_basis_forward(self, op: Op, set_images: bool) -> UnitCell: ...
    def find_nearest_image(self, ref: Position, pos: Position, asu: Asu = ...) -> NearestImage: ...
    @overload
    def find_nearest_pbc_image(self, fref: Fractional, fpos: Fractional, image_idx: int) -> NearestImage: ...
    @overload
    def find_nearest_pbc_image(self, ref: Position, pos: Position, image_idx: int) -> NearestImage: ...
    def find_nearest_pbc_position(self, ref: Position, pos: Position, image_idx: int, inverse: bool = ...) -> Position: ...
    def fractionalize(self, arg0: Position) -> Fractional: ...
    def get_hkl_limits(self, dmin: float) -> list[int]: ...
    def is_compatible_with_spacegroup(self, sg: SpaceGroup, eps: float = ...) -> bool: ...
    def is_crystal(self) -> bool: ...
    def is_similar(self, other: UnitCell, rel: float, deg: float) -> bool: ...
    @overload
    def is_special_position(self, pos: Position, max_dist: float = ...) -> int: ...
    @overload
    def is_special_position(self, fpos: Fractional, max_dist: float) -> int: ...
    def metric_tensor(self) -> SMat33d: ...
    def op_as_transform(self, arg0: Op) -> Transform: ...
    def orthogonalize(self, arg0: Fractional) -> Position: ...
    def orthogonalize_box(self, arg0: FractionalBox) -> PositionBox: ...
    def primitive_orth_matrix(self, centring_type: str) -> Mat33: ...
    def reciprocal(self) -> UnitCell: ...
    def reciprocal_metric_tensor(self) -> SMat33d: ...
    def set(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float) -> None: ...
    def volume_per_image(self) -> float: ...
    def __eq__(self, arg0: UnitCell) -> bool: ... # type: ignore[override]
    def __getstate__(self) -> tuple[float, float, float, float, float, float]: ...
    def __setstate__(self, arg0: tuple[float, float, float, float, float, float]) -> None: ...
    @property
    def a(self) -> float: ...
    @property
    def alpha(self) -> float: ...
    @property
    def b(self) -> float: ...
    @property
    def beta(self) -> float: ...
    @property
    def c(self) -> float: ...
    @property
    def frac(self) -> Transform: ...
    @property
    def fractionalization_matrix(self) -> Mat33: ...
    @property
    def gamma(self) -> float: ...
    @property
    def images(self) -> list[FTransform]: ...
    @property
    def orth(self) -> Transform: ...
    @property
    def orthogonalization_matrix(self) -> Mat33: ...
    @property
    def parameters(self) -> tuple[float, float, float, float, float, float]: ...
    @property
    def volume(self) -> float: ...

class ValueSigma:
    sigma: float
    value: float
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class ValueSigmaAsuData:
    spacegroup: SpaceGroup
    unit_cell: UnitCell
    def __init__(self, cell: UnitCell, sg: SpaceGroup, miller_array: npt.NDArray[np.int32], value_array: npt.NDArray[Any]) -> None: ...
    def copy(self) -> ValueSigmaAsuData: ...
    def count_equal_values(self, arg0: ValueSigmaAsuData) -> int: ...
    def ensure_asu(self, tnt_asu: bool = ...) -> None: ...
    def ensure_sorted(self) -> None: ...
    def make_1_d2_array(self) -> npt.NDArray[np.float32]: ...
    def make_d_array(self) -> npt.NDArray[np.float32]: ...
    def __getitem__(self, index: int) -> ValueSigmaHklValue: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    @property
    def miller_array(self) -> npt.NDArray[np.int32]: ...
    @property
    def value_array(self) -> npt.NDArray[Any]: ...

class ValueSigmaHklValue:
    value: ValueSigma
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @property
    def hkl(self) -> list[int]: ...

class ValuesView:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...

class Vec3:
    x: float
    y: float
    z: float
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...
    def approx(self, other: Vec3, epsilon: float) -> bool: ...
    def cross(self, arg0: Vec3) -> Vec3: ...
    def dot(self, arg0: Vec3) -> float: ...
    def fromlist(self, arg0: list[float]) -> None: ...
    def length(self) -> float: ...
    def tolist(self) -> list[float]: ...
    def __add__(self, arg0: Vec3) -> Vec3: ...
    def __getitem__(self, arg0: int) -> float: ...
    def __iadd__(self, arg0: Vec3) -> Vec3: ...
    def __imul__(self, arg0: float) -> Vec3: ...
    def __isub__(self, arg0: Vec3) -> Vec3: ...
    def __itruediv__(self, arg0: float) -> Vec3: ...
    def __mul__(self, arg0: float) -> Vec3: ...
    def __neg__(self) -> Vec3: ...
    def __rmul__(self, arg0: float) -> Vec3: ...
    def __setitem__(self, arg0: int, arg1: float) -> None: ...
    def __sub__(self, arg0: Vec3) -> Vec3: ...
    def __truediv__(self, arg0: float) -> Vec3: ...

class VectorMarkPtr:
    __hash__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VectorMarkPtr) -> None: ...
    @overload
    def __init__(self, arg0: Iterable[Any]) -> None: ...
    def append(self, x: NeighborSearch.Mark) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: NeighborSearch.Mark) -> int: ...
    @overload
    def extend(self, L: VectorMarkPtr) -> None: ...
    @overload
    def extend(self, L: Iterable[Any]) -> None: ...
    def insert(self, i: int, x: NeighborSearch.Mark) -> None: ...
    @overload
    def pop(self) -> NeighborSearch.Mark: ...
    @overload
    def pop(self, i: int) -> NeighborSearch.Mark: ...
    def remove(self, x: NeighborSearch.Mark) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: NeighborSearch.Mark) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    def __eq__(self, arg0: VectorMarkPtr) -> bool: ... # type: ignore[override]
    @overload
    def __getitem__(self, s: slice) -> VectorMarkPtr: ...
    @overload
    def __getitem__(self, arg0: int) -> NeighborSearch.Mark: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: VectorMarkPtr) -> bool: ... # type: ignore[override]
    @overload
    def __setitem__(self, arg0: int, arg1: NeighborSearch.Mark) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VectorMarkPtr) -> None: ...

def IT92_normalize() -> None: ...
def add_automatic_links(arg0: Model, arg1: Structure, arg2: MonLib) -> None: ...
def add_chemcomp_to_block(arg0: ChemComp, arg1: Block) -> None: ...
def align_sequence_to_polymer(full_seq: list[str], polymer: ResidueSpan, polymer_type: PolymerType, scoring: AlignmentScoring = ...) -> AlignmentResult: ...
def align_string_sequences(query: list[str], target: list[str], free_gapo: list[bool], scoring: AlignmentScoring = ...) -> AlignmentResult: ...
def as_refln_blocks(arg0: Document) -> ReflnBlocks: ...
def bessel_i1_over_i0(arg0: npt.NDArray[np.float64]) -> object: ...
def bincorr(nbins: npt.NDArray[np.int32], obs: npt.NDArray[np.float64], calc: npt.NDArray[np.float64]) -> list[Correlation]: ...
def binmean(nbins: npt.NDArray[np.int32], values: npt.NDArray[np.float64]) -> npt.NDArray[np.float64]: ...
def binrfactor(nbins: npt.NDArray[np.int32], obs: npt.NDArray[np.float64], calc: npt.NDArray[np.float64], riso: bool = ...) -> npt.NDArray[np.float64]: ...
def calculate_angle(arg0: Position, arg1: Position, arg2: Position) -> float: ...
def calculate_b_est(arg0: Atom) -> float: ...
def calculate_current_rmsd(fixed: ResidueSpan, movable: ResidueSpan, ptype: PolymerType, sel: SupSelect, altloc: str = ...) -> SupResult: ...
def calculate_dihedral(arg0: Position, arg1: Position, arg2: Position, arg3: Position) -> float: ...
def calculate_omega(residue: Residue, next_residue: Residue) -> float: ...
def calculate_phi_psi(prev_residue: Residue, residue: Residue, next_residue: Residue) -> list[float]: ...
def calculate_sequence_weight(sequence: list[str], unknown: float = ...) -> float: ...
def calculate_superposition(fixed: ResidueSpan, movable: ResidueSpan, ptype: PolymerType, sel: SupSelect, trim_cycles: int = ..., trim_cutoff: float = ..., altloc: str = ...) -> SupResult: ...
def calculate_superpositions_in_moving_window(fixed: ResidueSpan, movable: ResidueSpan, ptype: PolymerType, radius: float = ...) -> list[SupResult]: ...
@overload
def check_data_type_under_symmetry(arg0: ReflnBlock) -> DataType: ...
@overload
def check_data_type_under_symmetry(arg0: Mtz) -> DataType: ...
def combine_correlations(arg0: list[Correlation]) -> Correlation: ...
def count_reflections(cell: UnitCell, spacegroup: SpaceGroup, dmin: float, dmax: float = ..., unique: bool = ...) -> int: ...
def cromer_liberman(z: int, energy: float) -> tuple[float,float]: ...
def estimate_uncompressed_size(path: str) -> int: ...
def expand_if_pdb_code(code: str, filetype: str = ...) -> str: ...
def expand_pdb_code_to_path(arg0: str, arg1: str) -> str: ...
def expand_protein_one_letter(arg0: str) -> str: ...
def expand_protein_one_letter_string(arg0: str) -> list[str]: ...
def find_asu_brick(arg0: SpaceGroup) -> AsuBrick: ...
def find_best_plane(atoms: list[Atom]) -> list[float]: ...
def find_blobs_by_flood_fill(grid: FloatGrid, cutoff: float, min_volume: float = ..., min_score: float = ..., min_peak: float = ..., negate: bool = ...) -> list[Blob]: ...
def find_lattice_2fold_ops(reduced_cell: UnitCell, max_obliq: float) -> list[tuple[Op,float]]: ...
def find_lattice_symmetry(cell: UnitCell, centring: str, max_obliq: float) -> GroupOps: ...
def find_lattice_symmetry_r(arg0: UnitCell, arg1: float) -> GroupOps: ...
def find_spacegroup_by_name(hm: str, alpha: float = ..., gamma: float = ...) -> SpaceGroup: ...
def find_spacegroup_by_number(ccp4: int) -> SpaceGroup: ...
def find_spacegroup_by_ops(group_ops: GroupOps) -> SpaceGroup: ...
def find_tabulated_residue(name: str) -> ResidueInfo: ...
def find_twin_laws(cell: UnitCell, sg: SpaceGroup, max_obliq: float, all_ops: bool) -> list[Op]: ...
def flood_fill_above(grid: FloatGrid, seeds: list[Position], threshold: float, negate: bool = ...) -> Int8Grid: ...
def generators_from_hall(hall: str) -> GroupOps: ...
def get_distance_from_plane(pos: Position, coeff: list[float]) -> float: ...
def get_spacegroup_reference_setting(number: int) -> SpaceGroup: ...
def hkl_cif_as_refln_block(block: Block) -> ReflnBlock: ...
def interpolate_grid(dest: FloatGrid, src: FloatGrid, tr: Transform, order: int = ...) -> None: ...
def interpolate_grid_of_aligned_model2(dest: FloatGrid, src: FloatGrid, tr: Transform, dest_model: Model, radius: float, order: int = ...) -> None: ...
def is_pdb_code(arg0: str) -> bool: ...
def log_bessel_i0(arg0: npt.NDArray[np.float64]) -> object: ...
def log_cosh(arg0: npt.NDArray[np.float64]) -> object: ...
def make_address(arg0: Chain, arg1: Residue, arg2: Atom) -> AtomAddress: ...
def make_assembly(arg0: Assembly, arg1: Model, arg2: HowToNameCopiedChain) -> Model: ...
def make_chemcomp_from_block(arg0: Block) -> ChemComp: ...
def make_miller_array(cell: UnitCell, spacegroup: SpaceGroup, dmin: float, dmax: float = ..., unique: bool = ...) -> npt.NDArray[np.int32]: ...
def make_small_structure_from_block(block: Block) -> SmallStructure: ...
def make_structure_from_block(block: Block) -> Structure: ...
def make_structure_from_chemcomp_block(block: Block) -> Structure: ...
def make_triplet_part(xyz: list[int], w: int, style: str = ...) -> str: ...
def merge_atoms_in_expanded_model(model: Model, cell: UnitCell, max_dist: float = ...) -> None: ...
def mx_to_sx_structure(st: Structure, n: int = ...) -> SmallStructure: ...
@overload
def one_letter_code(arg0: list[str]) -> str: ...
@overload
def one_letter_code(arg0: ResidueSpan) -> str: ...
def parse_triplet(triplet: str) -> Op: ...
def parse_triplet_part(s: str) -> list[int]: ...
def prepare_blosum62_scoring() -> AlignmentScoring: ...
def prepare_crd(arg0: Structure, arg1: Topo, arg2: HydrogenChange, arg3: str) -> Block: ...
def prepare_refmac_crd(arg0: Structure, arg1: Topo, arg2: MonLib, arg3: HydrogenChange) -> Document: ...
def prepare_rst(arg0: Topo, arg1: MonLib, arg2: UnitCell) -> Block: ...
def prepare_topology(st: Structure, monlib: MonLib, model_index: int = ..., h_change: HydrogenChange = ..., reorder: bool = ..., warnings: object = ..., ignore_unknown_links: bool = ...) -> Topo: ...
def read_ccp4_map(path: str, setup: bool = ...) -> Ccp4Map: ...
def read_ccp4_mask(path: str, setup: bool = ...) -> Ccp4Mask: ...
def read_monomer_lib(monomer_dir: str, resnames: list[str], libin: str = ..., ignore_missing: bool = ...) -> MonLib: ...
def read_mtz_file(path: str) -> Mtz: ...
def read_pdb(filename: str, max_line_length: int = ..., split_chain_on_ter: bool = ...) -> Structure: ...
def read_pdb_string(s: str, max_line_length: int = ..., split_chain_on_ter: bool = ...) -> Structure: ...
def read_small_structure(path: str) -> SmallStructure: ...
def read_structure(path: str, merge_chain_parts: bool = ..., format: CoorFormat = ..., save_doc: Document = ...) -> Structure: ...
def seitz_to_op(arg0: list[list[float]]) -> Op: ...
def spacegroup_table() -> Iterator[Any]: ...
def spacegroup_table_itb() -> Iterator[Any]: ...
def superpose_positions(pos1: list[Position], pos2: list[Position], weight: list[float] = ...) -> SupResult: ...
def symops_from_hall(hall: str) -> GroupOps: ...
def transform_f_phi_grid_to_map(grid: ReciprocalComplexGrid) -> FloatGrid: ...
def transform_map_to_f_phi(map: FloatGrid, half_l: bool = ..., use_scale: bool = ...) -> ReciprocalComplexGrid: ...
