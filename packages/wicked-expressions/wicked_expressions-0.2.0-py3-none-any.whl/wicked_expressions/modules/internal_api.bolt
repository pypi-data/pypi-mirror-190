from dataclasses import dataclass
from typing import Union, List
import bolt_expressions.api as api

import ./sources as sources


@dataclass
class Scoreboard(api.Scoreboard):
    def objective(self, name: str, criteria: str = "dummy", prefixed=True, display_name=None):
        """Get a Score instance through the Scoreboard API"""
        if prefixed:
            name = self._expr.opts.objective_prefix + name

        if criteria == None:
            criteria = 'dummy'

        if name not in self.added_objectives:
            self.added_objectives.add(name)
            self.create_objective(name, criteria, display_name)


        return Score(self, name)

    def create_objective(self, name, criteria, display_name):
        init_path = generate_path('wicked_expressions/init')

        if display_name == None:
            display_name = name

        # default display_name color
        if isinstance(display_name, str):
            display_name = {"text": display_name, "color": "aqua"}

        merge function_tag minecraft:load {"values": [init_path]}
        append function init_path:
            scoreboard objectives add name criteria display_name

@dataclass
class Score(api.Score):
    def __getitem__(self, scoreholder: Union[str, List[str]]) -> sources.ScoreSource:
        if isinstance(scoreholder, str):
            return sources.ScoreSource.create(scoreholder, self.objective)
        
        tmp = []
        for holder in scoreholder:
            tmp.append(sources.ScoreSource.create(holder, self.objective))

        return tmp


@dataclass
class Data(api.Data):
    def storage(self, resource_location: str):
        return sources.DataSource.create("storage", resource_location)

    def entity(self, entity: str):
        return sources.DataSource.create("entity", entity)

    def block(self, position: str):
        return sources.DataSource.create("block", position)



