{"version":3,"file":"lib_index_js-webpack_sharing_consume_default_bpmn-moddle_bpmn-moddle-webpack_sharing_consume_-64f830.33e0c3a593dc586a773b.js","mappings":";;;;;;;;;;;;;;;;;;AAAgD;AACY;AACX;AACmB;AACpE,kCAAkC;AAClC;AACe;AACf,IAAI,0EAAiB;AACrB;AACA,eAAe,8DAAE;AACjB;AACA;AACA;AACA,oBAAoB,gDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,gDAAS;AACjB;AACA;AACA;AACA;AACA,gEAAQ,gBAAgB,qEAAY;AACpC;;;;;;;;;;;;;;;;AC1BsD;AACtD;AACA;AACA,iCAAiC,wDAAkB;AACnD;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLc;AACY;AACM;AACG;AACtB;AAC2C;AAC7C;AACiC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,mDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAU;AAC3C;AACA,wBAAwB,iDAAW;AACnC,wBAAwB,kEAAc;AACtC,wBAAwB,qEAAc;AACtC;AACA;AACA,iCAAiC,uEAAa;AAC9C,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA,oBAAoB,wDAAgB;AACpC;AACA;AACA;AACA,iCAAiC,0DAAkB;AACnD,oBAAoB,yDAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iBAAiB,sBAAsB;AAC/F;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gEAAgE,iBAAiB,0CAA0C,kDAAW,cAAc,2DAA2D,gCAAgC,uBAAuB,cAAc;AACpR;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;;;;;ACjKiC;AACd;AACH;AACkE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,6BAA6B,gDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iDAAO;AACX,sBAAsB,kDAAQ;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAQ;AACvB;AACA,eAAe,gDAAS;AACxB,QAAQ,gDAAS;AACjB;AACA,mBAAmB,gDAAS;AAC5B,iBAAiB,gDAAS;AAC1B,IAAI,8CAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8CAAO;AACX;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gDAAS;AACb,IAAI,gDAAS;AACb;AACA;AACA,sBAAsB,uDAAW;AACjC;AACA;AACA;AACA,SAAS;AACT,QAAQ,gDAAS;AACjB;AACA;AACA;AACA;AACA,sBAAsB,uDAAW;AACjC;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,gDAAS;AACjB;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,gDAAS;AACjB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY,IAAI,gCAAgC;AACjE,iBAAiB,gCAAgC;AACjD;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA","sources":["webpack://jupyterlab-bpmn/./lib/RobotModule/RobotFrameworkTask.js","webpack://jupyterlab-bpmn/./lib/RobotModule/index.js","webpack://jupyterlab-bpmn/./lib/index.js","webpack://jupyterlab-bpmn/./lib/utils.js"],"sourcesContent":["import { is } from 'bpmn-js/lib/util/ModelUtil';\nimport BaseRenderer from 'diagram-js/lib/draw/BaseRenderer';\nimport inherits from 'inherits/inherits_browser';\nimport { append as svgAppend, create as svgCreate } from 'tiny-svg';\nconst Robot = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmlld0JveD0iMCAwIDIwMi40MzI1IDIwMi4zNDEyNSIKICAgaGVpZ2h0PSIyMDIuMzQxMjUiCiAgIHdpZHRoPSIyMDIuNDMyNSIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgdmVyc2lvbj0iMS4xIgogICBpZD0ic3ZnMiI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTYiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgaWQ9InBhdGgxOCIKICAgICAgICAgZD0ibSAwLDE2MS44NzMgMTYxLjk0NiwwIEwgMTYxLjk0NiwwIDAsMCAwLDE2MS44NzMgWiIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMjAyLjM0MTI1KSIKICAgICBpZD0iZzEwIj48ZwogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMTYpIgogICAgICAgICBpZD0iZzE0Ij48ZwogICAgICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUyLjQ0NzcsODguMTI2OCkiCiAgICAgICAgICAgaWQ9ImcyMCI+PHBhdGgKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgICAgZD0ibSAwLDAgYyAwLDcuNiA2LjE3OSwxMy43NzkgMTMuNzcsMTMuNzc5IDcuNiwwIDEzLjc3OSwtNi4xNzkgMTMuNzc5LC0xMy43NzkgMCwtMi43NjkgLTIuMjM4LC01LjAwNyAtNC45OTgsLTUuMDA3IC0yLjc2MSwwIC00Ljk5OSwyLjIzOCAtNC45OTksNS4wMDcgMCwyLjA3OCAtMS42OTUsMy43NjUgLTMuNzgyLDMuNzY1IEMgMTEuNjkzLDMuNzY1IDkuOTk3LDIuMDc4IDkuOTk3LDAgOS45OTcsLTIuNzY5IDcuNzYsLTUuMDA3IDQuOTk5LC01LjAwNyAyLjIzOCwtNS4wMDcgMCwtMi43NjkgMCwwIG0gNTcuMDUsLTIzLjE1MyBjIDAsLTIuNzcxIC0yLjIzNywtNS4wMDcgLTQuOTk4LC01LjAwNyBsIC00Ni4zNzgsMCBjIC0yLjc2MSwwIC00Ljk5OSwyLjIzNiAtNC45OTksNS4wMDcgMCwyLjc2OSAyLjIzOCw1LjAwNyA0Ljk5OSw1LjAwNyBsIDQ2LjM3OCwwIGMgMi43NjEsMCA0Ljk5OCwtMi4yMzggNC45OTgsLTUuMDA3IE0gMzUuMzc5LC0yLjgwNSBjIC0xLjU0NSwyLjI5MSAtMC45NDEsNS4zOTggMS4zNSw2Ljk0MyBsIDExLjU5NCw3LjgzIGMgMi4yNzMsMS41OCA1LjM5OCwwLjk0MSA2Ljk0MywtMS4zMzIgMS41NDUsLTIuMjkgMC45NDEsLTUuMzk4IC0xLjM1LC02Ljk0MyBsIC0xMS41OTQsLTcuODMgYyAtMC44NTIsLTAuNTg2IC0xLjgyOSwtMC44NyAtMi43ODgsLTAuODcgLTEuNjA3LDAgLTMuMTg3LDAuNzgxIC00LjE1NSwyLjIwMiBtIDMxLjc0OCwtMzAuNzg2IGMgMCwtMC45NDUgLTAuMzc2LC0xLjg1MiAtMS4wNDUsLTIuNTIyIGwgLTguNjE3LC04LjYxNyBjIC0wLjY2OSwtMC42NjggLTEuNTc2LC0xLjA0NSAtMi41MjMsLTEuMDQ1IGwgLTUyLjgzMywwIGMgLTAuOTQ3LDAgLTEuODU0LDAuMzc3IC0yLjUyMywxLjA0NSBsIC04LjYxNyw4LjYxNyBjIC0wLjY2OSwwLjY3IC0xLjA0NSwxLjU3NyAtMS4wNDUsMi41MjIgbCAwLDUyLjc5OSBjIDAsMC45NDcgMC4zNzYsMS44NTQgMS4wNDUsMi41MjIgbCA4LjYxNyw4LjYxOSBjIDAuNjY5LDAuNjY4IDEuNTc2LDEuMDQ0IDIuNTIzLDEuMDQ0IGwgNTIuODMzLDAgYyAwLjk0NywwIDEuODU0LC0wLjM3NiAyLjUyMywtMS4wNDQgbCA4LjYxNywtOC42MTkgYyAwLjY2OSwtMC42NjggMS4wNDUsLTEuNTc1IDEuMDQ1LC0yLjUyMiBsIDAsLTUyLjc5OSB6IG0gNy4zMzQsNjEuMDg2IC0xMS4yNSwxMS4yNSBjIC0xLjcwNSwxLjcwNSAtNC4wMTgsMi42NjMgLTYuNDI4LDIuNjYzIGwgLTU2LjUyMywwIGMgLTIuNDEyLDAgLTQuNzI1LC0wLjk1OSAtNi40MywtMi42NjUgTCAtMTcuNDEyLDI3LjQ5NCBjIC0xLjcwNCwtMS43MDUgLTIuNjYxLC00LjAxNiAtMi42NjEsLTYuNDI3IGwgMCwtNTYuNTE1IGMgMCwtMi40MTEgMC45NTgsLTQuNzI1IDIuNjYzLC02LjQyOCBsIDExLjI1LC0xMS4yNSBjIDEuNzA1LC0xLjcwNSA0LjAxNywtMi42NjIgNi40MjgsLTIuNjYyIGwgNTYuNTE1LDAgYyAyLjQxLDAgNC43MjMsMC45NTcgNi40MjgsMi42NjIgbCAxMS4yNSwxMS4yNSBjIDEuNzA1LDEuNzAzIDIuNjYzLDQuMDE3IDIuNjYzLDYuNDI4IGwgMCw1Ni41MTQgYyAwLDIuNDEyIC0wLjk1OCw0LjcyNCAtMi42NjMsNi40MjkiIC8+PC9nPjwvZz48L2c+PC9nPjwvc3ZnPg==';\nlet _ = null;\nexport default function RobotRenderer(eventBus, bpmnRenderer) {\n    BaseRenderer.call(_, eventBus, 1500);\n    _.canRender = function (element) {\n        return is(element, 'bpmn:ServiceTask') && element.id.match(/robot/i);\n    };\n    _.drawShape = function (parent, element) {\n        bpmnRenderer.handlers['bpmn:Task'](parent, element);\n        const gfx = svgCreate('image', {\n            x: -1,\n            y: -1,\n            width: 32,\n            height: 32,\n            href: Robot,\n        });\n        svgAppend(parent, gfx);\n        return gfx;\n    };\n}\n_ = RobotRenderer;\ninherits(RobotRenderer, BaseRenderer);\nRobotRenderer.$inject = ['eventBus', 'bpmnRenderer'];\n","import RobotFrameworkTask from './RobotFrameworkTask';\nconst RobotModule = {\n    __init__: ['RobotFrameworkTask'],\n    RobotFrameworkTask: ['type', RobotFrameworkTask],\n};\nexport default RobotModule;\n","import { Widget } from '@lumino/widgets';\nimport BpmnViewer from 'bpmn-js/lib/NavigatedViewer';\nimport ModelingModule from 'bpmn-js/lib/features/modeling';\nimport TooltipsModule from 'diagram-js/lib/features/tooltips';\nimport RobotModule from './RobotModule';\nimport { clearSequenceFlow, renderActivities, renderSequenceFlow, } from './utils';\nimport html2canvas from 'html2canvas';\nimport camundaModdle from 'camunda-bpmn-moddle/resources/camunda.json';\n/**\n * The default mime type for the extension.\n */\nconst MIME_TYPE = 'application/bpmn+xml';\n/**\n * The class name added to the extension.\n */\nconst CLASS_NAME = 'mimerenderer-bpmn';\n/**\n * A widget for rendering bpmn.\n */\nexport class OutputWidget extends Widget {\n    /**\n     * Construct a new output widget.\n     */\n    constructor(options) {\n        super();\n        this._mimeType = options.mimeType;\n        this.addClass(CLASS_NAME);\n    }\n    /**\n     * Render bpmn into this widget's node.\n     */\n    async renderModel(model) {\n        try {\n            let changed = false;\n            let resized = false;\n            if (!this._bpmn) {\n                this._bpmn = new BpmnViewer({\n                    additionalModules: [\n                        RobotModule,\n                        ModelingModule,\n                        TooltipsModule,\n                    ],\n                    moddleExtensions: {\n                        camunda: camundaModdle,\n                    },\n                });\n                changed = true;\n            }\n            if (model.data[this._mimeType] &&\n                model.data[this._mimeType] !== this._xml) {\n                this._xml = model.data[this._mimeType];\n                await this._bpmn.importXML(this._xml);\n                changed = true;\n            }\n            if (model.data['application/bpmn+json'] &&\n                model.data['application/bpmn+json'] !== this._json) {\n                this._json = model.data['application/bpmn+json'];\n                changed = true;\n            }\n            if (this._bpmn) {\n                this._bpmn.attachTo(this.node);\n            }\n            if (this._bpmn && changed) {\n                const config = JSON.parse(model.data['application/bpmn+json'] || '{}');\n                if (config.activities || config.incidents) {\n                    renderActivities(this._bpmn, (config === null || config === void 0 ? void 0 : config.activities) || [], (config === null || config === void 0 ? void 0 : config.incidents) || []);\n                }\n                if (config.activities && config.path !== false) {\n                    const flow = this._flow || [];\n                    this._flow = renderSequenceFlow(this._bpmn, config.activities);\n                    clearSequenceFlow(flow);\n                }\n                if (config.style) {\n                    for (const name of Object.keys(config.style)) {\n                        this.node.style.setProperty(name, config.style[name]);\n                        if (name === 'height' && config.style[name] !== this._height) {\n                            this._height = config.style[name];\n                            resized = true;\n                        }\n                    }\n                }\n                if (this._bpmn && config.zoom) {\n                    if (config.zoom !== this._zoom) {\n                        const registry = this._bpmn.get('elementRegistry');\n                        if (registry.get(config.zoom)) {\n                            this._bpmn.get('canvas').zoom(1.0, registry.get(config.zoom));\n                        }\n                        else {\n                            this._bpmn.get('canvas').zoom('fit-viewport', 'auto');\n                            if (config.zoom !== 'fit-viewport') {\n                                this._bpmn.get('canvas').zoom(config.zoom, 'auto');\n                            }\n                        }\n                        this._zoom = config.zoom;\n                    }\n                }\n                else if (this._bpmn && resized) {\n                    this._bpmn.get('canvas').zoom('fit-viewport', 'auto');\n                }\n                if (config.colors) {\n                    const modeling = this._bpmn.get('modeling');\n                    const registry = this._bpmn.get('elementRegistry');\n                    for (const name of Object.keys(config.colors)) {\n                        const colors = config.colors[name];\n                        const element = registry.get(name);\n                        if (element) {\n                            modeling.setColor(element, colors);\n                        }\n                    }\n                }\n                const svg = (await this._bpmn.saveSVG())[\"svg\"];\n                model.setData({\n                    data: Object.assign(Object.assign({}, model.data), { 'image/svg+xml': svg }),\n                    metadata: model.metadata,\n                });\n                if (!!config.activities) {\n                    setTimeout(async () => {\n                        model.setData({\n                            data: Object.assign(Object.assign({}, model.data), { 'image/svg+xml': svg, 'image/png': (await html2canvas(this.node, { \"backgroundColor\": null, \"ignoreElements\": function (el) { return el.tagName === \"SVG\"; } })).toDataURL().split(';base64,')[1] }),\n                            metadata: model.metadata,\n                        });\n                    }, 1000);\n                }\n            }\n        }\n        catch (e) {\n            console.warn(e);\n        }\n        return Promise.resolve();\n    }\n}\n/**\n * A mime renderer factory for bpmn data.\n */\nexport const rendererFactory = {\n    safe: true,\n    mimeTypes: [MIME_TYPE],\n    createRenderer: (options) => new OutputWidget(options),\n};\n/**\n * Extension definition.\n */\nconst extension = {\n    id: 'jupyterlab-bpmn:plugin',\n    rendererFactory,\n    rank: 70,\n    dataType: 'string',\n    fileTypes: [\n        {\n            name: 'bpmn',\n            mimeTypes: [MIME_TYPE],\n            extensions: ['.bpmn'],\n        },\n    ],\n    documentWidgetFactoryOptions: {\n        name: 'JupyterLab BPMN viewer',\n        primaryFileType: 'bpmn',\n        fileTypes: ['bpmn'],\n        defaultFor: ['bpmn'],\n    },\n};\nexport default extension;\n","import { filter, forEach, map, uniqueBy } from 'min-dash';\nimport { query as domQuery } from 'min-dom';\nimport { createCurve } from 'svg-curves';\nimport { append as svgAppend, attr as svgAttr, create as svgCreate, remove as svgRemove, } from 'tiny-svg';\nconst FILL = '#52B415';\nconst getConnections = (activities, elementRegistry) => {\n    var _a, _b;\n    const validActivity = new Map();\n    const startTimesById = new Map();\n    const endTimesById = new Map();\n    const connectionDenyList = new Set();\n    for (const activity of activities) {\n        if (activity.endTime && !activity.canceled) {\n            validActivity.set(activity.activityId, true);\n        }\n        if (endTimesById.has(activity.activityId)) {\n            const endTimes = (_a = endTimesById.get(activity.activityId)) !== null && _a !== void 0 ? _a : [];\n            endTimes.push(activity.endTime || 'Z');\n        }\n        else {\n            endTimesById.set(activity.activityId, [activity.endTime || 'Z']);\n        }\n        if (startTimesById.has(activity.activityId)) {\n            const startTimes = (_b = startTimesById.get(activity.activityId)) !== null && _b !== void 0 ? _b : [];\n            startTimes.push(activity.startTime || 'Z');\n        }\n        else {\n            startTimesById.set(activity.activityId, [activity.startTime || 'Z']);\n        }\n    }\n    const elementById = new Map(map(activities, (activity) => {\n        var _a, _b;\n        const element = elementRegistry.get(activity.activityId);\n        // Side effect! Populate connectionDenyList for gateways by sorting outgoing\n        // paths in ascending order by their target activity start time and list everything\n        // but the first ones in deny list to prevent coloring them as active.\n        if (activity.activityType === 'exclusiveGateway' &&\n            element.outgoing.length) {\n            const activeConnections = [];\n            const myEndTimes = endTimesById.get(activity.activityId) || [];\n            for (let idx = 0; idx < myEndTimes.length; idx++) {\n                const myEndTime = myEndTimes[idx];\n                element.outgoing.sort((a, b) => {\n                    var _a, _b;\n                    const startTimesA = startTimesById.get(a.target.id) || [];\n                    const startTimesB = startTimesById.get(b.target.id) || [];\n                    const startA = (_a = startTimesA === null || startTimesA === void 0 ? void 0 : startTimesA[idx]) !== null && _a !== void 0 ? _a : 'Z';\n                    const startB = (_b = startTimesB === null || startTimesB === void 0 ? void 0 : startTimesB[idx]) !== null && _b !== void 0 ? _b : 'Z';\n                    return startTimesA.length <= idx\n                        ? 1\n                        : startTimesB.length <= idx\n                            ? -1\n                            : startA < myEndTime\n                                ? 1\n                                : startB < myEndTime\n                                    ? -1\n                                    : startA > startB\n                                        ? 1\n                                        : startA < startB\n                                            ? -1\n                                            : 0;\n                });\n                activeConnections.push(element.outgoing[0].id);\n            }\n            for (const connection of element.outgoing) {\n                if (!activeConnections.includes(connection.id) &&\n                    ((_b = (_a = connection) === null || _a === void 0 ? void 0 : _a.target) === null || _b === void 0 ? void 0 : _b.type) !== 'bpmn:ParallelGateway') {\n                    connectionDenyList.add(connection.id);\n                }\n            }\n        }\n        return [activity.activityId, element];\n    }));\n    const getActivityConnections = (activityId) => {\n        var _a;\n        const current = elementById.get(activityId);\n        const currentEndTimes = (_a = endTimesById.get(activityId)) !== null && _a !== void 0 ? _a : [];\n        if (current && validActivity.get(activityId)) {\n            const incoming = filter(current.incoming, (connection) => {\n                var _a;\n                if (connectionDenyList.has(connection.id)) {\n                    return false;\n                }\n                const incomingEndTimes = validActivity.get(connection.source.id)\n                    ? (_a = endTimesById.get(connection.source.id)) !== null && _a !== void 0 ? _a : [] : [];\n                return incomingEndTimes.reduce((acc, iET) => acc ||\n                    currentEndTimes.reduce((acc_, cET) => acc_ || iET <= cET, false), false);\n            });\n            const outgoing = filter(current.outgoing, (connection) => {\n                var _a;\n                if (connectionDenyList.has(connection.id)) {\n                    return false;\n                }\n                const outgoingEndTimes = (_a = endTimesById.get(connection.target.id)) !== null && _a !== void 0 ? _a : [];\n                return outgoingEndTimes.reduce((acc, oET) => acc ||\n                    currentEndTimes.reduce((acc_, cET) => acc_ || oET >= cET, false), false);\n            });\n            return [...incoming, ...outgoing];\n        }\n        else {\n            return [];\n        }\n    };\n    let connections = [];\n    forEach(Array.from(elementById.keys()), (activityId) => {\n        connections = uniqueBy('id', [\n            ...connections,\n            ...getActivityConnections(activityId),\n        ]);\n    });\n    return connections;\n};\nconst getMid = (shape) => {\n    return {\n        x: shape.x + shape.width / 2,\n        y: shape.y + shape.height / 2,\n    };\n};\nconst notDottedTypes = ['bpmn:SubProcess'];\nconst getDottedConnections = (connections) => {\n    const dottedConnections = [];\n    connections.forEach((connection) => {\n        const { target } = connection;\n        connections.forEach((c) => {\n            const { source } = c;\n            if (source === target && !notDottedTypes.includes(source.type)) {\n                dottedConnections.push({\n                    waypoints: [\n                        connection.waypoints[connection.waypoints.length - 1],\n                        getMid(target),\n                        c.waypoints[0],\n                    ],\n                });\n            }\n        });\n    });\n    return dottedConnections;\n};\nexport const renderSequenceFlow = (viewer, activities) => {\n    const registry = viewer.get('elementRegistry');\n    const canvas = viewer.get('canvas');\n    const layer = canvas.getLayer('processInstance', 1);\n    const connections = getConnections(activities !== null && activities !== void 0 ? activities : [], registry);\n    const paths = [];\n    let defs = domQuery('defs', canvas._svg);\n    if (!defs) {\n        defs = svgCreate('defs');\n        svgAppend(canvas._svg, defs);\n    }\n    const marker = svgCreate('marker');\n    const path = svgCreate('path');\n    svgAttr(marker, {\n        id: 'arrow',\n        viewBox: '0 0 10 10',\n        refX: 7,\n        refY: 5,\n        markerWidth: 4,\n        markerHeight: 4,\n        orient: 'auto-start-reverse',\n    });\n    svgAttr(path, {\n        d: 'M 0 0 L 10 5 L 0 10 z',\n        fill: FILL,\n        stroke: 'blue',\n        strokeWidth: 0,\n    });\n    svgAppend(marker, path);\n    svgAppend(defs, marker);\n    paths.push(marker);\n    for (const connection of connections) {\n        const curve = createCurve(connection.waypoints, {\n            markerEnd: 'url(#arrow)',\n            stroke: FILL,\n            strokeWidth: 4,\n        });\n        svgAppend(layer, curve);\n        paths.push(curve);\n    }\n    const connections_ = getDottedConnections(connections);\n    for (const connection of connections_) {\n        const curve = createCurve(connection.waypoints, {\n            strokeDasharray: '1 8',\n            strokeLinecap: 'round',\n            stroke: FILL,\n            strokeWidth: 4,\n        });\n        svgAppend(layer, curve);\n        paths.push(curve);\n    }\n    return paths;\n};\nexport const clearSequenceFlow = (nodes) => {\n    for (const node of nodes) {\n        svgRemove(node);\n    }\n};\nexport const renderActivities = (viewer, activities, incidents) => {\n    const historic = {};\n    const active = {};\n    const incident = {};\n    const message = {};\n    for (const activity of activities) {\n        const id = activity.activityId;\n        historic[id] = historic[id] ? historic[id] + 1 : 1;\n        if (!activity.endTime) {\n            active[id] = active[id] ? active[id] + 1 : 1;\n        }\n    }\n    for (const incident_ of incidents) {\n        const id = incident_.activityId;\n        active[id] = active[id] ? active[id] + 1 : 1;\n        incident[id] = incident[id] ? incident[id] + 1 : 1;\n        message[id] = message[id]\n            ? `${message[id]}\\n${incident_.incidentMessage || ''}`.replace(/\\s+$/g, '')\n            : `${incident_.incidentMessage || ''}`.replace(/\\s+$/g, '');\n    }\n    const overlays = viewer.get('overlays');\n    const old = overlays.get({ type: 'badge' });\n    for (const id of Object.keys(historic)) {\n        const overlay = document.createElement('span');\n        overlay.innerText = `${historic[id]}`;\n        overlay.className = 'badge';\n        overlay.style.cssText = `\nbackground: lightgray;\nborder: 1px solid #143d52;\ncolor: #143d52;\n\ndisplay: inline-block;\nmin-width: 10px;\npadding: 3px 7px;\nfont-size: 12px;\nfont-weight: bold;\nline-height: 1;\ntext-align: center;\nwhite-space: nowrap;\nvertical-align: middle;\nborder-radius: 10px;\n `;\n        overlays.add(id.split('#')[0], 'badge', {\n            position: {\n                bottom: 17,\n                right: 10,\n            },\n            html: overlay,\n        });\n    }\n    for (const id of Object.keys(active)) {\n        const activeOverlay = document.createElement('span');\n        activeOverlay.innerText = `${active[id]}`;\n        activeOverlay.className = 'badge';\n        activeOverlay.style.cssText = `\nbackground: #70b8db;\nborder: 1px solid #143d52;\ncolor: #143d52;\n\ndisplay: inline-block;\nmin-width: 10px;\npadding: 3px 7px;\nfont-size: 12px;\nfont-weight: bold;\nline-height: 1;\ntext-align: center;\nwhite-space: nowrap;\nvertical-align: middle;\nborder-radius: 10px;\n `;\n        overlays.add(id.split('#')[0], 'badge', {\n            position: {\n                bottom: 17,\n                left: -10,\n            },\n            html: activeOverlay,\n        });\n    }\n    for (const id of Object.keys(incident)) {\n        if (incident[id]) {\n            const incidentOverlay = document.createElement('span');\n            incidentOverlay.innerText = `${incident[id]}`;\n            incidentOverlay.title = `${message[id]}`;\n            incidentOverlay.className = 'badge';\n            incidentOverlay.style.cssText = `\nbackground: #b94a48;\nborder: 1px solid #140808;\ncolor: #ffffff;\n\ndisplay: inline-block;\nmin-width: 10px;\npadding: 3px 7px;\nfont-size: 12px;\nfont-weight: bold;\nline-height: 1;\ntext-align: center;\nwhite-space: nowrap;\nvertical-align: middle;\nborder-radius: 10px;\n `;\n            overlays.add(id.split('#')[0], 'badge', {\n                position: {\n                    bottom: 17,\n                    right: 10,\n                },\n                html: incidentOverlay,\n            });\n        }\n    }\n    for (const overlay of old) {\n        overlays.remove(overlay.id);\n    }\n};\n"],"names":[],"sourceRoot":""}