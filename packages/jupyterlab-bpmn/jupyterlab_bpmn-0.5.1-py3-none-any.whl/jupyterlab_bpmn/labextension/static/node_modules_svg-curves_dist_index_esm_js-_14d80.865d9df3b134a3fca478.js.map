{"version":3,"file":"node_modules_svg-curves_dist_index_esm_js-_14d80.865d9df3b134a3fca478.js","mappings":";;;;;;;;;;;;;;;AAAuC;AACC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB;AACA,uCAAuC;AACvC,aAAa,gDAAM;AACnB;AACA;AACA;AACA,EAAE,8CAAI,OAAO,gDAAM,GAAG;AACtB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6CAAG;AACd;AACA,GAAG;AACH;AACA;AACA;AACA,QAAQ,2BAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB","sources":["webpack://jupyterlab-bpmn/./node_modules/svg-curves/dist/index.esm.js"],"sourcesContent":["import { assign, map } from 'min-dash';\nimport { create, attr } from 'tiny-svg';\n\nvar DEFAULT_ATTRS = {\r\n  fill: 'none',\r\n  stroke: 'black',\r\n  strokeWidth: 2\r\n};\r\n\r\n/**\r\n * @typedef {Object} Point\r\n *\r\n * @param {number} point.x\r\n * @param {number} point.y\r\n */\r\n\r\n/**\r\n * Create SVG curve.\r\n *\r\n * @param {Array<Point>} points\r\n * @param {Object} [attrs]\r\n */\r\nfunction createCurve(points, attrs = {}) {\r\n  var path = create('path');\r\n\r\n  var data = getData(points);\r\n\r\n  attr(path, assign({}, DEFAULT_ATTRS, attrs, {\r\n    d: data\r\n  }));\r\n\r\n  return path;\r\n}\r\n\r\nfunction getData(points) {\r\n  var segments = getSegments(points);\r\n\r\n  if (segments.length === 1) {\r\n    return getSingleSegmentData(segments[0]);\r\n  }\r\n\r\n  var startSegment = segments.shift();\r\n\r\n  return [\r\n    moveTo(startSegment.start),\r\n    quadraticCurve(startSegment.controlPoint, startSegment.end)\r\n  ].concat(map(segments, function(segment) {\r\n    return sameCurve(segment.controlPoint, segment.end);\r\n  })).join(' ');\r\n}\r\n\r\nfunction getSingleSegmentData(segment) {\r\n  var { start, controlPoint, end } = segment;\r\n\r\n  return [\r\n    moveTo(start),\r\n    quadraticCurve(controlPoint, end)\r\n  ].join(' ');\r\n}\r\n\r\nfunction getSegments(points) {\r\n  if (points.length === 2) {\r\n    return [\r\n      {\r\n        start: points[0],\r\n        controlPoint: getMid(points[0], points[1]),\r\n        end: points[1]\r\n      }\r\n    ];\r\n  }\r\n\r\n  if (points.length === 3) {\r\n    return [\r\n      {\r\n        start: points[0],\r\n        controlPoint: points[1],\r\n        end: points[2]\r\n      }\r\n    ];\r\n  }\r\n\r\n  return [ getStartSegment(points) ]\r\n    .concat(getMiddleSegments(points))\r\n    .concat([ getEndSegment(points) ]);\r\n}\r\n\r\nfunction getStartSegment(points) {\r\n  return {\r\n    start: points[0],\r\n    controlPoint: points[1],\r\n    end: getMid(points[1], points[2])\r\n  };\r\n}\r\n\r\nfunction getMiddleSegments(points) {\r\n  var segments = [];\r\n\r\n  for (var i = 1; i < points.length - 3; i++) {\r\n    segments.push({\r\n      start: getMid(points[ i ], points[ i + 1 ]),\r\n      controlPoint: points[ i + 1 ],\r\n      end: getMid(points[ i + 1 ], points[ i + 2 ])\r\n    });\r\n  }\r\n\r\n  return segments;\r\n}\r\n\r\nfunction getEndSegment(points) {\r\n  return {\r\n    start: getMid(points[points.length - 3], points[points.length - 2]),\r\n    controlPoint: points[points.length - 2],\r\n    end: points[points.length - 1]\r\n  };\r\n}\r\n\r\nfunction moveTo(a) {\r\n  return [ 'M', a.x, a.y ].join(' ');\r\n}\r\n\r\nfunction quadraticCurve(a, b) {\r\n  return [ 'Q', a.x, a.y, b.x, b.y ].join(' ');\r\n}\r\n\r\nfunction sameCurve(a, b) {\r\n  return [ 'S', a.x, a.y, b.x, b.y ].join(' ');\r\n}\r\n\r\nfunction getMid(a, b) {\r\n  return {\r\n    x: Math.round((a.x + b.x) / 2),\r\n    y: Math.round((a.y + b.y) / 2)\r\n  };\r\n}\n\nexport { createCurve };\n"],"names":[],"sourceRoot":""}