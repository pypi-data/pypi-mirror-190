{"version":3,"file":"vendors-node_modules_jupyter-widgets_jupyterlab-manager_lib_index_js.59b910c0b4e867588e17.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAC6C;AACV;AACnC,iEAAe,+CAAqB,EAAC;AACY;AACiC;AACtC;AAC1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRlB;AACA;AAC+D;AACN;AACR;AACY;AACJ;AACL;AACI;AACF;AACV;AACoB;AACU;AAC5B;AAC9C;AACA;AACiF;AACpC;AACW;AACH;AACiB;AACtE;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0DAAO;AAC5C,0CAA0C,sDAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAM;AAC9B,uBAAuB,0DAAO;AAC9B,8BAA8B,0DAAO;AACrC,iCAAiC,0DAAO;AACxC,sCAAsC,sDAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,uBAAuB,oDAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAoB;AAClD;AACA;AACA,oBAAoB,2DAAoB;AACxC,yCAAyC,sDAAc;AACvD,KAAK;AACL,eAAe,kEAAkB;AACjC;AACA,sCAAsC,2DAAoB;AAC1D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,uEAAmB;AAClC;AACA,QAAQ,kEAAgB;AACxB,QAAQ,yEAAgB;AACxB,QAAQ,2DAAS;AACjB,QAAQ,mEAAe;AACvB,QAAQ,iEAAW;AACnB;AACA,cAAc,yEAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,+EAA+E,oEAAc;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2EAAwB;AAC5C,qBAAqB,4EAAyB;AAC9C;AACA;AACA,2DAA2D,kBAAkB,kCAAkC;AAC/G;AACA,6BAA6B,6BAA6B;AAC1D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2DAAoB;AACxC,yCAAyC,sDAAc;AACvD,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB,IAAI,eAAe;AACvF,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,cAAc,gEAAgE;AAC9E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP,oDAAoD,0EAA4B,CAAC;AACjF,eAAe,yEAA2B;AAC1C;AACA;AACA;AACA;AACA,qBAAqB,0EAA4B;AACjD;AACA,6BAA6B,8DAAgB;AAC7C,4BAA4B,6DAAe;AAC3C,+BAA+B,gEAAkB;AACjD,gCAAgC,iEAAmB;AACnD,6BAA6B,8DAAgB;AAC7C,4BAA4B,6DAAe;AAC3C,4BAA4B,6DAAe;AAC3C,2BAA2B,4DAAc;AACzC,iCAAiC,kEAAoB;AACrD,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACO;AACP,wDAAwD,2FAAwB,CAAC;AACjF,eAAe,yEAA2B;AAC1C;AACA;AACA;AACA;AACA,qBAAqB,2FAAwB;AAC7C;AACA;AACA,oBAAoB,qOAA8C;AAClE;AACA,gCAAgC,mBAAO,CAAC,2HAA2B;AACnE,qBAAqB,4CAAE;AACvB;AACA,qBAAqB,CAA8B;AACnD,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACO;AACP,sDAAsD,2DAAqB,CAAC;AAC5E,eAAe,yEAA2B;AAC1C;AACA;AACA;AACA;AACA,qBAAqB,2DAAqB;AAC1C,uBAAuB,WAAW,+DAAY,oDAAE;AAChD,SAAS;AACT,KAAK;AACL;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAgB;AACxD;AACA;AACA,KAAK;AACL,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;;ACvQ3B;AACA;AACoD;AACZ;AACxC;AACA;AACA;AACO,6BAA6B,kDAAK;AACzC;AACA;AACA,4BAA4B,8DAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@datalayer/jupyter-react/../../../../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/index.js","webpack://@datalayer/jupyter-react/../../../../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/plugin.js","webpack://@datalayer/jupyter-react/../../../../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/renderer.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport WidgetManagerProvider from './plugin';\nimport * as output from './output';\nexport default WidgetManagerProvider;\nexport { registerWidgetManager } from './plugin';\nexport { KernelWidgetManager, LabWidgetManager, WidgetManager, } from './manager';\nexport { WidgetRenderer } from './renderer';\nexport { output };\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { INotebookTracker, } from '@jupyterlab/notebook';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { ILoggerRegistry } from '@jupyterlab/logconsole';\nimport { toArray, filter } from '@lumino/algorithm';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { AttachedProperty } from '@lumino/properties';\nimport { WidgetRenderer } from './renderer';\nimport { WidgetManager, WIDGET_VIEW_MIMETYPE } from './manager';\nimport { OutputModel, OutputView, OUTPUT_WIDGET_VERSION } from './output';\nimport * as base from '@jupyter-widgets/base';\n// We import only the version from the specific module in controls so that the\n// controls code can be split and dynamically loaded in webpack.\nimport { JUPYTER_CONTROLS_VERSION } from '@jupyter-widgets/controls/lib/version';\nimport '@jupyter-widgets/base/css/index.css';\nimport '@jupyter-widgets/controls/css/widgets-base.css';\nimport { KernelMessage } from '@jupyterlab/services';\nimport { ITranslator, nullTranslator } from '@jupyterlab/translation';\nconst WIDGET_REGISTRY = [];\n/**\n * The cached settings.\n */\nconst SETTINGS = { saveState: false };\n/**\n * Iterate through all widget renderers in a notebook.\n */\nfunction* widgetRenderers(nb) {\n    for (const cell of nb.widgets) {\n        if (cell.model.type === 'code') {\n            for (const codecell of cell.outputArea.widgets) {\n                for (const output of toArray(codecell.children())) {\n                    if (output instanceof WidgetRenderer) {\n                        yield output;\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * Iterate through all matching linked output views\n */\nfunction* outputViews(app, path) {\n    const linkedViews = filter(app.shell.widgets(), (w) => w.id.startsWith('LinkedOutputView-') && w.path === path);\n    for (const view of toArray(linkedViews)) {\n        for (const outputs of toArray(view.children())) {\n            for (const output of toArray(outputs.children())) {\n                if (output instanceof WidgetRenderer) {\n                    yield output;\n                }\n            }\n        }\n    }\n}\nfunction* chain(...args) {\n    for (const it of args) {\n        yield* it;\n    }\n}\nexport function registerWidgetManager(context, rendermime, renderers) {\n    let wManager = Private.widgetManagerProperty.get(context);\n    if (!wManager) {\n        wManager = new WidgetManager(context, rendermime, SETTINGS);\n        WIDGET_REGISTRY.forEach((data) => wManager.register(data));\n        Private.widgetManagerProperty.set(context, wManager);\n    }\n    for (const r of renderers) {\n        r.manager = wManager;\n    }\n    // Replace the placeholder widget renderer with one bound to this widget\n    // manager.\n    rendermime.removeMimeType(WIDGET_VIEW_MIMETYPE);\n    rendermime.addFactory({\n        safe: false,\n        mimeTypes: [WIDGET_VIEW_MIMETYPE],\n        createRenderer: (options) => new WidgetRenderer(options, wManager),\n    }, -10);\n    return new DisposableDelegate(() => {\n        if (rendermime) {\n            rendermime.removeMimeType(WIDGET_VIEW_MIMETYPE);\n        }\n        wManager.dispose();\n    });\n}\n/**\n * The widget manager provider.\n */\nexport const managerPlugin = {\n    id: '@jupyter-widgets/jupyterlab-manager:plugin',\n    requires: [IRenderMimeRegistry],\n    optional: [\n        INotebookTracker,\n        ISettingRegistry,\n        IMainMenu,\n        ILoggerRegistry,\n        ITranslator,\n    ],\n    provides: base.IJupyterWidgetRegistry,\n    activate: activateWidgetExtension,\n    autoStart: true,\n};\nfunction updateSettings(settings) {\n    SETTINGS.saveState = settings.get('saveState').composite;\n}\n/**\n * Activate the widget extension.\n */\nfunction activateWidgetExtension(app, rendermime, tracker, settingRegistry, menu, loggerRegistry, translator) {\n    const { commands } = app;\n    const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab_widgets');\n    const bindUnhandledIOPubMessageSignal = (nb) => {\n        if (!loggerRegistry) {\n            return;\n        }\n        const wManager = Private.widgetManagerProperty.get(nb.context);\n        if (wManager) {\n            wManager.onUnhandledIOPubMessage.connect((sender, msg) => {\n                const logger = loggerRegistry.getLogger(nb.context.path);\n                let level = 'warning';\n                if (KernelMessage.isErrorMsg(msg) ||\n                    (KernelMessage.isStreamMsg(msg) && msg.content.name === 'stderr')) {\n                    level = 'error';\n                }\n                const data = Object.assign(Object.assign({}, msg.content), { output_type: msg.header.msg_type });\n                logger.rendermime = nb.content.rendermime;\n                logger.log({ type: 'output', data, level });\n            });\n        }\n    };\n    if (settingRegistry !== null) {\n        settingRegistry\n            .load(managerPlugin.id)\n            .then((settings) => {\n            settings.changed.connect(updateSettings);\n            updateSettings(settings);\n        })\n            .catch((reason) => {\n            console.error(reason.message);\n        });\n    }\n    // Add a placeholder widget renderer.\n    rendermime.addFactory({\n        safe: false,\n        mimeTypes: [WIDGET_VIEW_MIMETYPE],\n        createRenderer: (options) => new WidgetRenderer(options),\n    }, -10);\n    if (tracker !== null) {\n        tracker.forEach((panel) => {\n            registerWidgetManager(panel.context, panel.content.rendermime, chain(widgetRenderers(panel.content), outputViews(app, panel.context.path)));\n            bindUnhandledIOPubMessageSignal(panel);\n        });\n        tracker.widgetAdded.connect((sender, panel) => {\n            registerWidgetManager(panel.context, panel.content.rendermime, chain(widgetRenderers(panel.content), outputViews(app, panel.context.path)));\n            bindUnhandledIOPubMessageSignal(panel);\n        });\n    }\n    if (settingRegistry !== null) {\n        // Add a command for automatically saving (jupyter-)widget state.\n        commands.addCommand('@jupyter-widgets/jupyterlab-manager:saveWidgetState', {\n            label: trans.__('Save Widget State Automatically'),\n            execute: (args) => {\n                return settingRegistry\n                    .set(managerPlugin.id, 'saveState', !SETTINGS.saveState)\n                    .catch((reason) => {\n                    console.error(`Failed to set ${managerPlugin.id}: ${reason.message}`);\n                });\n            },\n            isToggled: () => SETTINGS.saveState,\n        });\n    }\n    if (menu) {\n        menu.settingsMenu.addGroup([\n            { command: '@jupyter-widgets/jupyterlab-manager:saveWidgetState' },\n        ]);\n    }\n    return {\n        registerWidget(data) {\n            WIDGET_REGISTRY.push(data);\n        },\n    };\n}\n/**\n * The base widgets.\n */\nexport const baseWidgetsPlugin = {\n    id: `@jupyter-widgets/jupyterlab-manager:base-${base.JUPYTER_WIDGETS_VERSION}`,\n    requires: [base.IJupyterWidgetRegistry],\n    autoStart: true,\n    activate: (app, registry) => {\n        registry.registerWidget({\n            name: '@jupyter-widgets/base',\n            version: base.JUPYTER_WIDGETS_VERSION,\n            exports: {\n                WidgetModel: base.WidgetModel,\n                WidgetView: base.WidgetView,\n                DOMWidgetView: base.DOMWidgetView,\n                DOMWidgetModel: base.DOMWidgetModel,\n                LayoutModel: base.LayoutModel,\n                LayoutView: base.LayoutView,\n                StyleModel: base.StyleModel,\n                StyleView: base.StyleView,\n                ErrorWidgetView: base.ErrorWidgetView,\n            },\n        });\n    },\n};\n/**\n * The control widgets.\n */\nexport const controlWidgetsPlugin = {\n    id: `@jupyter-widgets/jupyterlab-manager:controls-${JUPYTER_CONTROLS_VERSION}`,\n    requires: [base.IJupyterWidgetRegistry],\n    autoStart: true,\n    activate: (app, registry) => {\n        registry.registerWidget({\n            name: '@jupyter-widgets/controls',\n            version: JUPYTER_CONTROLS_VERSION,\n            exports: () => {\n                return new Promise((resolve, reject) => {\n                    require.ensure(['@jupyter-widgets/controls'], (require) => {\n                        // eslint-disable-next-line @typescript-eslint/no-var-requires\n                        resolve(require('@jupyter-widgets/controls'));\n                    }, (err) => {\n                        reject(err);\n                    }, '@jupyter-widgets/controls');\n                });\n            },\n        });\n    },\n};\n/**\n * The output widget.\n */\nexport const outputWidgetPlugin = {\n    id: `@jupyter-widgets/jupyterlab-manager:output-${OUTPUT_WIDGET_VERSION}`,\n    requires: [base.IJupyterWidgetRegistry],\n    autoStart: true,\n    activate: (app, registry) => {\n        registry.registerWidget({\n            name: '@jupyter-widgets/output',\n            version: OUTPUT_WIDGET_VERSION,\n            exports: { OutputModel, OutputView },\n        });\n    },\n};\nexport default [\n    managerPlugin,\n    baseWidgetsPlugin,\n    controlWidgetsPlugin,\n    outputWidgetPlugin,\n];\nvar Private;\n(function (Private) {\n    /**\n     * A private attached property for a widget manager.\n     */\n    Private.widgetManagerProperty = new AttachedProperty({\n        name: 'widgetManager',\n        create: (owner) => undefined,\n    });\n})(Private || (Private = {}));\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { Panel } from '@lumino/widgets';\n/**\n * A renderer for widgets.\n */\nexport class WidgetRenderer extends Panel {\n    constructor(options, manager) {\n        super();\n        this._manager = new PromiseDelegate();\n        this._rerenderMimeModel = null;\n        this.mimeType = options.mimeType;\n        if (manager) {\n            this.manager = manager;\n        }\n    }\n    /**\n     * The widget manager.\n     */\n    set manager(value) {\n        value.restored.connect(this._rerender, this);\n        this._manager.resolve(value);\n    }\n    async renderModel(model) {\n        const source = model.data[this.mimeType];\n        // Let's be optimistic, and hope the widget state will come later.\n        this.node.textContent = 'Loading widget...';\n        const manager = await this._manager.promise;\n        // If there is no model id, the view was removed, so hide the node.\n        if (source.model_id === '') {\n            this.hide();\n            return Promise.resolve();\n        }\n        let wModel;\n        try {\n            // Presume we have a DOMWidgetModel. Should we check for sure?\n            wModel = (await manager.get_model(source.model_id));\n        }\n        catch (err) {\n            if (manager.restoredStatus) {\n                // The manager has been restored, so this error won't be going away.\n                this.node.textContent = 'Error displaying widget: model not found';\n                this.addClass('jupyter-widgets');\n                console.error(err);\n                return;\n            }\n            // Store the model for a possible rerender\n            this._rerenderMimeModel = model;\n            return;\n        }\n        // Successful getting the model, so we don't need to try to rerender.\n        this._rerenderMimeModel = null;\n        let widget;\n        try {\n            widget = (await manager.create_view(wModel)).luminoWidget;\n        }\n        catch (err) {\n            this.node.textContent = 'Error displaying widget';\n            this.addClass('jupyter-widgets');\n            console.error(err);\n            return;\n        }\n        // Clear any previous loading message.\n        this.node.textContent = '';\n        this.addWidget(widget);\n        // When the widget is disposed, hide this container and make sure we\n        // change the output model to reflect the view was closed.\n        widget.disposed.connect(() => {\n            this.hide();\n            source.model_id = '';\n        });\n    }\n    /**\n     * Dispose the resources held by the manager.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._manager = null;\n        super.dispose();\n    }\n    _rerender() {\n        if (this._rerenderMimeModel) {\n            // Clear the error message\n            this.node.textContent = '';\n            this.removeClass('jupyter-widgets');\n            // Attempt to rerender.\n            this.renderModel(this._rerenderMimeModel);\n        }\n    }\n}\n"],"names":[],"sourceRoot":""}