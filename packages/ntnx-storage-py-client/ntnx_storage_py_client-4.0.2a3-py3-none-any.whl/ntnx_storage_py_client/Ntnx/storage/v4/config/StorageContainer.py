# coding: utf-8


"""
IGNORE:
    Nutanix Storage Versioned APIs

    Manages volume groups and storage containers in Nutanix cluster.  # noqa: E501

    OpenAPI spec version: 4.0.2-alpha-3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from ntnx_storage_py_client.Ntnx.common.v1.config.IPAddressOrFQDN import IPAddressOrFQDN  # noqa: F401,E501
from ntnx_storage_py_client.Ntnx.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
from ntnx_storage_py_client.Ntnx.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
from ntnx_storage_py_client.Ntnx.storage.v4.config.ErasureCodeStatus import ErasureCodeStatus  # noqa: F401,E501
from ntnx_storage_py_client.Ntnx.storage.v4.config.FingerPrintOnWrite import FingerPrintOnWrite  # noqa: F401,E501
from ntnx_storage_py_client.Ntnx.storage.v4.config.OnDiskDedup import OnDiskDedup  # noqa: F401,E501

"""
IGNORE:
NOTE: This class is auto generated by the swagger code generator program.

Do not edit the class manually.
IGNORE
"""


class StorageContainer(ExternalizableAbstractModel):
    """StorageContainer - a model defined in Swagger"""
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """ # noqa: E501
    swagger_types = {
        'container_id': 'str',
        'container_ext_id': 'str',
        'owner_uuid': 'str',
        'name': 'str',
        'cluster_ext_id': 'str',
        'storage_pool_uuid': 'str',
        'marked_for_removal': 'bool',
        'max_capacity': 'int',
        'total_explicit_reserved_capacity': 'int',
        'total_implicit_reserved_capacity': 'int',
        'advertised_capacity': 'int',
        'replication_factor': 'int',
        'oplog_replication_factor': 'int',
        'nfs_whitelist_address': 'list[common.v1.config.IPAddressOrFQDN]',
        'is_nfs_whitelist_inherited': 'bool',
        'random_io_preference': 'list[str]',
        'seq_io_preference': 'list[str]',
        'down_migrate_times_in_secs': 'dict(str, int)',
        'erasure_code': 'storage.v4.config.ErasureCodeStatus',
        'inline_ec_enabled': 'bool',
        'prefer_higher_ec_fault_domain': 'bool',
        'erasure_code_delay_secs': 'int',
        'finger_print_on_write': 'storage.v4.config.FingerPrintOnWrite',
        'on_disk_dedup': 'storage.v4.config.OnDiskDedup',
        'compression_enabled': 'bool',
        'compression_delay_in_secs': 'int',
        'is_nutanix_managed': 'bool',
        'enable_software_encryption': 'bool',
        'vstore_name_list': 'list[str]',
        'mapped_remote_containers': 'dict(str, str)',
        'encrypted': 'bool',
        'affinity_host_uuid': 'str',
        'ext_id': 'str',
        'links': 'list[common.v1.response.ApiLink]',
        'tenant_id': 'str',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'container_id': 'containerId',
        'container_ext_id': 'containerExtId',
        'owner_uuid': 'ownerUuid',
        'name': 'name',
        'cluster_ext_id': 'clusterExtId',
        'storage_pool_uuid': 'storagePoolUuid',
        'marked_for_removal': 'markedForRemoval',
        'max_capacity': 'maxCapacity',
        'total_explicit_reserved_capacity': 'totalExplicitReservedCapacity',
        'total_implicit_reserved_capacity': 'totalImplicitReservedCapacity',
        'advertised_capacity': 'advertisedCapacity',
        'replication_factor': 'replicationFactor',
        'oplog_replication_factor': 'oplogReplicationFactor',
        'nfs_whitelist_address': 'nfsWhitelistAddress',
        'is_nfs_whitelist_inherited': 'isNfsWhitelistInherited',
        'random_io_preference': 'randomIoPreference',
        'seq_io_preference': 'seqIoPreference',
        'down_migrate_times_in_secs': 'downMigrateTimesInSecs',
        'erasure_code': 'erasureCode',
        'inline_ec_enabled': 'inlineEcEnabled',
        'prefer_higher_ec_fault_domain': 'preferHigherECFaultDomain',
        'erasure_code_delay_secs': 'erasureCodeDelaySecs',
        'finger_print_on_write': 'fingerPrintOnWrite',
        'on_disk_dedup': 'onDiskDedup',
        'compression_enabled': 'compressionEnabled',
        'compression_delay_in_secs': 'compressionDelayInSecs',
        'is_nutanix_managed': 'isNutanixManaged',
        'enable_software_encryption': 'enableSoftwareEncryption',
        'vstore_name_list': 'vstoreNameList',
        'mapped_remote_containers': 'mappedRemoteContainers',
        'encrypted': 'encrypted',
        'affinity_host_uuid': 'affinityHostUuid',
        'ext_id': 'extId',
        'links': 'links',
        'tenant_id': 'tenantId',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, container_id=None, container_ext_id=None, owner_uuid=None, name=None, cluster_ext_id=None, storage_pool_uuid=None, marked_for_removal=None, max_capacity=None, total_explicit_reserved_capacity=None, total_implicit_reserved_capacity=None, advertised_capacity=None, replication_factor=None, oplog_replication_factor=None, nfs_whitelist_address=None, is_nfs_whitelist_inherited=None, random_io_preference=None, seq_io_preference=None, down_migrate_times_in_secs=None, erasure_code=None, inline_ec_enabled=None, prefer_higher_ec_fault_domain=None, erasure_code_delay_secs=None, finger_print_on_write=None, on_disk_dedup=None, compression_enabled=None, compression_delay_in_secs=None, is_nutanix_managed=None, enable_software_encryption=None, vstore_name_list=None, mapped_remote_containers=None, encrypted=None, affinity_host_uuid=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
        """StorageContainer - a model defined in Swagger
            
        """
        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
        self.__container_id = None
        self.__container_ext_id = None
        self.__owner_uuid = None
        self.__name = None
        self.__cluster_ext_id = None
        self.__storage_pool_uuid = None
        self.__marked_for_removal = None
        self.__max_capacity = None
        self.__total_explicit_reserved_capacity = None
        self.__total_implicit_reserved_capacity = None
        self.__advertised_capacity = None
        self.__replication_factor = None
        self.__oplog_replication_factor = None
        self.__nfs_whitelist_address = None
        self.__is_nfs_whitelist_inherited = None
        self.__random_io_preference = None
        self.__seq_io_preference = None
        self.__down_migrate_times_in_secs = None
        self.__erasure_code = None
        self.__inline_ec_enabled = None
        self.__prefer_higher_ec_fault_domain = None
        self.__erasure_code_delay_secs = None
        self.__finger_print_on_write = None
        self.__on_disk_dedup = None
        self.__compression_enabled = None
        self.__compression_delay_in_secs = None
        self.__is_nutanix_managed = None
        self.__enable_software_encryption = None
        self.__vstore_name_list = None
        self.__mapped_remote_containers = None
        self.__encrypted = None
        self.__affinity_host_uuid = None
        self.discriminator = None
        if container_id is not None:
            self.__container_id = container_id
        if container_ext_id is not None:
            self.__container_ext_id = container_ext_id
        if owner_uuid is not None:
            self.__owner_uuid = owner_uuid
        self.__name = name
        if cluster_ext_id is not None:
            self.__cluster_ext_id = cluster_ext_id
        if storage_pool_uuid is not None:
            self.__storage_pool_uuid = storage_pool_uuid
        if marked_for_removal is not None:
            self.__marked_for_removal = marked_for_removal
        if max_capacity is not None:
            self.__max_capacity = max_capacity
        if total_explicit_reserved_capacity is not None:
            self.__total_explicit_reserved_capacity = total_explicit_reserved_capacity
        if total_implicit_reserved_capacity is not None:
            self.__total_implicit_reserved_capacity = total_implicit_reserved_capacity
        if advertised_capacity is not None:
            self.__advertised_capacity = advertised_capacity
        if replication_factor is not None:
            self.__replication_factor = replication_factor
        if oplog_replication_factor is not None:
            self.__oplog_replication_factor = oplog_replication_factor
        if nfs_whitelist_address is not None:
            self.__nfs_whitelist_address = nfs_whitelist_address
        if is_nfs_whitelist_inherited is not None:
            self.__is_nfs_whitelist_inherited = is_nfs_whitelist_inherited
        if random_io_preference is not None:
            self.__random_io_preference = random_io_preference
        if seq_io_preference is not None:
            self.__seq_io_preference = seq_io_preference
        if down_migrate_times_in_secs is not None:
            self.__down_migrate_times_in_secs = down_migrate_times_in_secs
        if erasure_code is not None:
            self.__erasure_code = erasure_code
        if inline_ec_enabled is not None:
            self.__inline_ec_enabled = inline_ec_enabled
        if prefer_higher_ec_fault_domain is not None:
            self.__prefer_higher_ec_fault_domain = prefer_higher_ec_fault_domain
        if erasure_code_delay_secs is not None:
            self.__erasure_code_delay_secs = erasure_code_delay_secs
        if finger_print_on_write is not None:
            self.__finger_print_on_write = finger_print_on_write
        if on_disk_dedup is not None:
            self.__on_disk_dedup = on_disk_dedup
        if compression_enabled is not None:
            self.__compression_enabled = compression_enabled
        if compression_delay_in_secs is not None:
            self.__compression_delay_in_secs = compression_delay_in_secs
        if is_nutanix_managed is not None:
            self.__is_nutanix_managed = is_nutanix_managed
        if enable_software_encryption is not None:
            self.__enable_software_encryption = enable_software_encryption
        if vstore_name_list is not None:
            self.__vstore_name_list = vstore_name_list
        if mapped_remote_containers is not None:
            self.__mapped_remote_containers = mapped_remote_containers
        if encrypted is not None:
            self.__encrypted = encrypted
        if affinity_host_uuid is not None:
            self.__affinity_host_uuid = affinity_host_uuid

    def _initialize_object_type(self):
        return 'storage.v4.config.StorageContainer'

    def _initialize_fq_object_type(self):
        return 'storage.v4.r0.a3.config.StorageContainer'


    @property
    def container_id(self):
        """`{ str }`
            \nId of the storage container instance.
        """ # noqa: E501
        return self.__container_id

    @container_id.setter
    def container_id(self, container_id):

        self.__container_id = container_id

    @property
    def container_ext_id(self):
        """`{ str }`
            \nUuid of the storage container.
        """ # noqa: E501
        return self.__container_ext_id

    @container_ext_id.setter
    def container_ext_id(self, container_ext_id):
        if container_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', container_ext_id):  # noqa: E501
            raise ValueError(r"Invalid value for `container_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__container_ext_id = container_ext_id

    @property
    def owner_uuid(self):
        """`{ str }`
            \nUuid of the storage container.
        """ # noqa: E501
        return self.__owner_uuid

    @owner_uuid.setter
    def owner_uuid(self, owner_uuid):
        if owner_uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', owner_uuid):  # noqa: E501
            raise ValueError(r"Invalid value for `owner_uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__owner_uuid = owner_uuid

    @property
    def name(self):
        """`{ str }`
            \nName of the storage container.
        """ # noqa: E501
        return self.__name

    @name.setter
    def name(self, name):
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
        if name is not None and len(name) > 75:
            raise ValueError("Invalid value for `name`, length must be less than or equal to `75`")  # noqa: E501

        self.__name = name

    @property
    def cluster_ext_id(self):
        """`{ str }`
            \nOwning cluster uuid of storage container.
        """ # noqa: E501
        return self.__cluster_ext_id

    @cluster_ext_id.setter
    def cluster_ext_id(self, cluster_ext_id):
        if cluster_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_ext_id):  # noqa: E501
            raise ValueError(r"Invalid value for `cluster_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__cluster_ext_id = cluster_ext_id

    @property
    def storage_pool_uuid(self):
        """`{ str }`
            \nOwning storage pool uuid of the container instance.
        """ # noqa: E501
        return self.__storage_pool_uuid

    @storage_pool_uuid.setter
    def storage_pool_uuid(self, storage_pool_uuid):
        if storage_pool_uuid is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', storage_pool_uuid):  # noqa: E501
            raise ValueError(r"Invalid value for `storage_pool_uuid`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__storage_pool_uuid = storage_pool_uuid

    @property
    def marked_for_removal(self):
        """`{ bool }`
            \nWhether storage container is marked for removal.
        """ # noqa: E501
        return self.__marked_for_removal

    @marked_for_removal.setter
    def marked_for_removal(self, marked_for_removal):

        self.__marked_for_removal = marked_for_removal

    @property
    def max_capacity(self):
        """`{ int }`
            \nMaximum capacity of the storage container.
        """ # noqa: E501
        return self.__max_capacity

    @max_capacity.setter
    def max_capacity(self, max_capacity):

        self.__max_capacity = max_capacity

    @property
    def total_explicit_reserved_capacity(self):
        """`{ int }`
            \nTotal explicit reserved capacity of the storage container.
        """ # noqa: E501
        return self.__total_explicit_reserved_capacity

    @total_explicit_reserved_capacity.setter
    def total_explicit_reserved_capacity(self, total_explicit_reserved_capacity):

        self.__total_explicit_reserved_capacity = total_explicit_reserved_capacity

    @property
    def total_implicit_reserved_capacity(self):
        """`{ int }`
            \nTotal implicit reserved capacity of the storage container.
        """ # noqa: E501
        return self.__total_implicit_reserved_capacity

    @total_implicit_reserved_capacity.setter
    def total_implicit_reserved_capacity(self, total_implicit_reserved_capacity):

        self.__total_implicit_reserved_capacity = total_implicit_reserved_capacity

    @property
    def advertised_capacity(self):
        """`{ int }`
            \nTotal advertised capacity of the storage container.
        """ # noqa: E501
        return self.__advertised_capacity

    @advertised_capacity.setter
    def advertised_capacity(self, advertised_capacity):

        self.__advertised_capacity = advertised_capacity

    @property
    def replication_factor(self):
        """`{ int }`
            \nReplication factor of the storage container.
        """ # noqa: E501
        return self.__replication_factor

    @replication_factor.setter
    def replication_factor(self, replication_factor):

        self.__replication_factor = replication_factor

    @property
    def oplog_replication_factor(self):
        """`{ int }`
            \nOplog replication factor of the storage container.
        """ # noqa: E501
        return self.__oplog_replication_factor

    @oplog_replication_factor.setter
    def oplog_replication_factor(self, oplog_replication_factor):

        self.__oplog_replication_factor = oplog_replication_factor

    @property
    def nfs_whitelist_address(self):
        """`{ list[common.v1.config.IPAddressOrFQDN] }`
            \nList of Nfs addresses which needs to be whitelisted.
        """ # noqa: E501
        return self.__nfs_whitelist_address

    @nfs_whitelist_address.setter
    def nfs_whitelist_address(self, nfs_whitelist_address):

        self.__nfs_whitelist_address = nfs_whitelist_address

    @property
    def is_nfs_whitelist_inherited(self):
        """`{ bool }`
            \nWhether Nfs whitelist inherited from global config.
        """ # noqa: E501
        return self.__is_nfs_whitelist_inherited

    @is_nfs_whitelist_inherited.setter
    def is_nfs_whitelist_inherited(self, is_nfs_whitelist_inherited):

        self.__is_nfs_whitelist_inherited = is_nfs_whitelist_inherited

    @property
    def random_io_preference(self):
        """`{ list[str] }`
            \nList of random IO preference tier.
        """ # noqa: E501
        return self.__random_io_preference

    @random_io_preference.setter
    def random_io_preference(self, random_io_preference):

        self.__random_io_preference = random_io_preference

    @property
    def seq_io_preference(self):
        """`{ list[str] }`
            \nList of sequential IO preference tier.
        """ # noqa: E501
        return self.__seq_io_preference

    @seq_io_preference.setter
    def seq_io_preference(self, seq_io_preference):

        self.__seq_io_preference = seq_io_preference

    @property
    def down_migrate_times_in_secs(self):
        """`{ dict(str, int) }`
            \nMap of down migrate time in seconds for random io preference tier.
        """ # noqa: E501
        return self.__down_migrate_times_in_secs

    @down_migrate_times_in_secs.setter
    def down_migrate_times_in_secs(self, down_migrate_times_in_secs):

        self.__down_migrate_times_in_secs = down_migrate_times_in_secs

    @property
    def erasure_code(self):
        """`{ storage.v4.config.ErasureCodeStatus }`
            
        """ # noqa: E501
        return self.__erasure_code

    @erasure_code.setter
    def erasure_code(self, erasure_code):

        self.__erasure_code = erasure_code

    @property
    def inline_ec_enabled(self):
        """`{ bool }`
            \nWhether inline erasure coding is enabled.
        """ # noqa: E501
        return self.__inline_ec_enabled

    @inline_ec_enabled.setter
    def inline_ec_enabled(self, inline_ec_enabled):

        self.__inline_ec_enabled = inline_ec_enabled

    @property
    def prefer_higher_ec_fault_domain(self):
        """`{ bool }`
            \nWhether to prefer higher erasure code fault domain.
        """ # noqa: E501
        return self.__prefer_higher_ec_fault_domain

    @prefer_higher_ec_fault_domain.setter
    def prefer_higher_ec_fault_domain(self, prefer_higher_ec_fault_domain):

        self.__prefer_higher_ec_fault_domain = prefer_higher_ec_fault_domain

    @property
    def erasure_code_delay_secs(self):
        """`{ int }`
            \nErasure code delay in seconds.
        """ # noqa: E501
        return self.__erasure_code_delay_secs

    @erasure_code_delay_secs.setter
    def erasure_code_delay_secs(self, erasure_code_delay_secs):

        self.__erasure_code_delay_secs = erasure_code_delay_secs

    @property
    def finger_print_on_write(self):
        """`{ storage.v4.config.FingerPrintOnWrite }`
            
        """ # noqa: E501
        return self.__finger_print_on_write

    @finger_print_on_write.setter
    def finger_print_on_write(self, finger_print_on_write):

        self.__finger_print_on_write = finger_print_on_write

    @property
    def on_disk_dedup(self):
        """`{ storage.v4.config.OnDiskDedup }`
            
        """ # noqa: E501
        return self.__on_disk_dedup

    @on_disk_dedup.setter
    def on_disk_dedup(self, on_disk_dedup):

        self.__on_disk_dedup = on_disk_dedup

    @property
    def compression_enabled(self):
        """`{ bool }`
            \nWhether compression is enabled.
        """ # noqa: E501
        return self.__compression_enabled

    @compression_enabled.setter
    def compression_enabled(self, compression_enabled):

        self.__compression_enabled = compression_enabled

    @property
    def compression_delay_in_secs(self):
        """`{ int }`
            \nCompression delay in seconds.
        """ # noqa: E501
        return self.__compression_delay_in_secs

    @compression_delay_in_secs.setter
    def compression_delay_in_secs(self, compression_delay_in_secs):

        self.__compression_delay_in_secs = compression_delay_in_secs

    @property
    def is_nutanix_managed(self):
        """`{ bool }`
            \nWhether container is managed by nutanix.
        """ # noqa: E501
        return self.__is_nutanix_managed

    @is_nutanix_managed.setter
    def is_nutanix_managed(self, is_nutanix_managed):

        self.__is_nutanix_managed = is_nutanix_managed

    @property
    def enable_software_encryption(self):
        """`{ bool }`
            \nWhether container to enable software encryption.
        """ # noqa: E501
        return self.__enable_software_encryption

    @enable_software_encryption.setter
    def enable_software_encryption(self, enable_software_encryption):

        self.__enable_software_encryption = enable_software_encryption

    @property
    def vstore_name_list(self):
        """`{ list[str] }`
            \nList of volume stores in the container.
        """ # noqa: E501
        return self.__vstore_name_list

    @vstore_name_list.setter
    def vstore_name_list(self, vstore_name_list):

        self.__vstore_name_list = vstore_name_list

    @property
    def mapped_remote_containers(self):
        """`{ dict(str, str) }`
            \nMap of remote containers.
        """ # noqa: E501
        return self.__mapped_remote_containers

    @mapped_remote_containers.setter
    def mapped_remote_containers(self, mapped_remote_containers):

        self.__mapped_remote_containers = mapped_remote_containers

    @property
    def encrypted(self):
        """`{ bool }`
            \nWhether container is encrypted or not.
        """ # noqa: E501
        return self.__encrypted

    @encrypted.setter
    def encrypted(self, encrypted):

        self.__encrypted = encrypted

    @property
    def affinity_host_uuid(self):
        """`{ str }`
            \nAffinity host id for RF 1 container.
        """ # noqa: E501
        return self.__affinity_host_uuid

    @affinity_host_uuid.setter
    def affinity_host_uuid(self, affinity_host_uuid):

        self.__affinity_host_uuid = affinity_host_uuid

    def _to_dict(self, sanitize):
        """
        Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.
        :param bool sanitize
        """

        result = {}

        for attr, attr_type in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                    value
                ))
            elif hasattr(value, "_to_dict"):
                result[attr] = value._to_dict(sanitize)
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1]._to_dict(sanitize))
                    if hasattr(item[1], "_to_dict") else item,
                    six.iteritems(value)
                ))
            else:
                if sanitize:
                    if value is not None:
                        result[attr] = value
                else:
                    result[attr] = value
        if issubclass(StorageContainer, dict):
            for key, value in six.iteritems(self):
                result[key] = value

        return result

    def to_dict(self):
        """Returns the model properties as a dict"""
        return self._to_dict(False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self._to_dict(True))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, StorageContainer):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

