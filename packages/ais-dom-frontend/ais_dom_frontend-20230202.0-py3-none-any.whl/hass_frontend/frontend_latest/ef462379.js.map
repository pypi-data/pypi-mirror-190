{"version":3,"file":"ef462379.js","mappings":";;AA4GA;AAKA;;AAEA;AAEA;;;AAGA;AACA;;AAEA;;AAxBA;;AAEA;;AA4BA;;AA6CA;AACA;AAGA;;AAEA;;AAOA;;AAEA;;AAGA;;AAEA;;AAGA;AACA;AACA;AACA;AACA;;;AAIA;;;AAGA;AAGA;AAOA;;;;AAIA;;;;AAOA;AACA;;;AAGA;AACA;;;;AAQA;;;AAIA;AA2HA;AAKA;AAeA;AA0BA;AAKA;AAYA;AACA;AAMA;;AAqBA;AACA;;AAEA;AATA;AAwCA;AAKA;AAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4KA;ACllBA;AAMA;;;;AAKA;;;AAMA;AAEA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxCA;;;;;;;;;;;;;;;;;;;;;AAsXA","sources":["webpack://home-assistant-frontend/./src/panels/logbook/ha-logbook-renderer.ts","webpack://home-assistant-frontend/./src/panels/logbook/ha-logbook.ts"],"sourcesContent":["import { VisibilityChangedEvent } from \"@lit-labs/virtualizer\";\nimport type { HassEntity } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, eventOptions, property } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport { formatDate } from \"../../common/datetime/format_date\";\nimport { formatTimeWithSeconds } from \"../../common/datetime/format_time\";\nimport { restoreScroll } from \"../../common/decorators/restore-scroll\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { navigate } from \"../../common/navigate\";\nimport { computeTimelineColor } from \"../../components/chart/timeline-chart/timeline-color\";\nimport \"../../components/entity/state-badge\";\nimport \"../../components/ha-circular-progress\";\nimport \"../../components/ha-icon-next\";\nimport \"../../components/ha-relative-time\";\nimport {\n  createHistoricState,\n  localizeStateMessage,\n  localizeTriggerSource,\n  LogbookEntry,\n} from \"../../data/logbook\";\nimport { TraceContexts } from \"../../data/trace\";\nimport {\n  buttonLinkStyle,\n  haStyle,\n  haStyleScrollbar,\n} from \"../../resources/styles\";\nimport { HomeAssistant } from \"../../types\";\nimport { brandsUrl } from \"../../util/brands-url\";\n\ndeclare global {\n  interface HASSDomEvents {\n    \"hass-logbook-live\": { enable: boolean };\n  }\n}\n\nconst triggerDomains = [\"script\", \"automation\"];\n\nconst hasContext = (item: LogbookEntry) =>\n  item.context_event_type || item.context_state || item.context_message;\nconst stripEntityId = (message: string, entityId?: string) =>\n  entityId ? message.replace(entityId, \" \") : message;\n\n@customElement(\"ha-logbook-renderer\")\nclass HaLogbookRenderer extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public userIdToName = {};\n\n  @property({ attribute: false })\n  public traceContexts: TraceContexts = {};\n\n  @property({ attribute: false }) public entries: LogbookEntry[] = [];\n\n  @property({ type: Boolean, attribute: \"narrow\" })\n  public narrow = false;\n\n  @property({ type: Boolean, attribute: \"virtualize\", reflect: true })\n  public virtualize = false;\n\n  @property({ type: Boolean, attribute: \"show-indicator\" })\n  public showIndicator = false;\n\n  @property({ type: Boolean, attribute: \"no-icon\" })\n  public noIcon = false;\n\n  @property({ type: Boolean, attribute: \"no-name\" })\n  public noName = false;\n\n  @property({ type: Boolean, attribute: \"relative-time\" })\n  public relativeTime = false;\n\n  // @ts-ignore\n  @restoreScroll(\".container\") private _savedScrollPos?: number;\n\n  protected shouldUpdate(changedProps: PropertyValues<this>) {\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    const languageChanged =\n      oldHass === undefined || oldHass.locale !== this.hass.locale;\n\n    return (\n      changedProps.has(\"entries\") ||\n      changedProps.has(\"traceContexts\") ||\n      languageChanged\n    );\n  }\n\n  protected render(): TemplateResult {\n    if (!this.entries?.length) {\n      return html`\n        <div class=\"container no-entries\">\n          ${this.hass.localize(\"ui.components.logbook.entries_not_found\")}\n        </div>\n      `;\n    }\n\n    return html`\n      <div\n        class=\"container ha-scrollbar ${classMap({\n          narrow: this.narrow,\n          \"no-name\": this.noName,\n          \"no-icon\": this.noIcon,\n        })}\"\n        @scroll=${this._saveScrollPos}\n      >\n        ${this.virtualize\n          ? html`<lit-virtualizer\n              @visibilityChanged=${this._visibilityChanged}\n              scroller\n              class=\"ha-scrollbar\"\n              .items=${this.entries}\n              .renderItem=${this._renderLogbookItem}\n            >\n            </lit-virtualizer>`\n          : this.entries.map((item, index) =>\n              this._renderLogbookItem(item, index)\n            )}\n      </div>\n    `;\n  }\n\n  private _renderLogbookItem = (\n    item: LogbookEntry,\n    index: number\n  ): TemplateResult => {\n    if (!item || index === undefined) {\n      return html``;\n    }\n    const previous = this.entries[index - 1] as LogbookEntry | undefined;\n    const seenEntityIds: string[] = [];\n    const currentStateObj = item.entity_id\n      ? this.hass.states[item.entity_id]\n      : undefined;\n    const historicStateObj = currentStateObj\n      ? createHistoricState(currentStateObj, item.state!)\n      : undefined;\n    const domain = item.entity_id\n      ? computeDomain(item.entity_id)\n      : // Domain is there if there is no entity ID.\n        item.domain!;\n    const overrideImage =\n      !historicStateObj &&\n      !item.icon &&\n      !item.state &&\n      domain &&\n      isComponentLoaded(this.hass, domain)\n        ? brandsUrl({\n            domain: domain!,\n            type: \"icon\",\n            useFallback: true,\n            darkOptimized: this.hass.themes?.darkMode,\n          })\n        : undefined;\n\n    const traceContext =\n      triggerDomains.includes(item.domain!) &&\n      item.context_id! in this.traceContexts\n        ? this.traceContexts[item.context_id!]\n        : undefined;\n\n    const hasTrace = traceContext !== undefined;\n\n    return html`\n      <div\n        class=\"entry-container ${classMap({ clickable: hasTrace })}\"\n        .traceLink=${traceContext\n          ? `/config/${traceContext.domain}/trace/${traceContext.item_id}?run_id=${traceContext.run_id}`\n          : undefined}\n        @click=${this._handleClick}\n      >\n        ${index === 0 ||\n        (item?.when &&\n          previous?.when &&\n          new Date(item.when * 1000).toDateString() !==\n            new Date(previous.when * 1000).toDateString())\n          ? html`\n              <h4 class=\"date\">\n                ${formatDate(new Date(item.when * 1000), this.hass.locale)}\n              </h4>\n            `\n          : html``}\n\n        <div class=\"entry ${classMap({ \"no-entity\": !item.entity_id })}\">\n          <div class=\"icon-message\">\n            ${!this.noIcon\n              ? html`\n                  <state-badge\n                    .hass=${this.hass}\n                    .overrideIcon=${item.icon}\n                    .overrideImage=${overrideImage}\n                    .stateObj=${item.icon ? undefined : historicStateObj}\n                    .stateColor=${false}\n                  ></state-badge>\n                `\n              : \"\"}\n            ${this.showIndicator ? this._renderIndicator(item) : \"\"}\n            <div class=\"message-relative_time\">\n              <div class=\"message\">\n                ${!this.noName // Used for more-info panel (single entity case)\n                  ? this._renderEntity(item.entity_id, item.name, hasTrace)\n                  : \"\"}\n                ${this._renderMessage(\n                  item,\n                  seenEntityIds,\n                  domain,\n                  historicStateObj,\n                  hasTrace\n                )}\n                ${this._renderContextMessage(item, seenEntityIds, hasTrace)}\n              </div>\n              <div class=\"secondary\">\n                <span\n                  >${formatTimeWithSeconds(\n                    new Date(item.when * 1000),\n                    this.hass.locale\n                  )}</span\n                >\n                -\n                <ha-relative-time\n                  .hass=${this.hass}\n                  .datetime=${item.when * 1000}\n                  capitalize\n                ></ha-relative-time>\n                ${item.context_user_id ? html`${this._renderUser(item)}` : \"\"}\n                ${hasTrace\n                  ? `- ${this.hass.localize(\n                      \"ui.components.logbook.show_trace\"\n                    )}`\n                  : \"\"}\n              </div>\n            </div>\n          </div>\n          ${hasTrace ? html`<ha-icon-next></ha-icon-next>` : \"\"}\n        </div>\n      </div>\n    `;\n  };\n\n  @eventOptions({ passive: true })\n  private _saveScrollPos(e: Event) {\n    this._savedScrollPos = (e.target as HTMLDivElement).scrollTop;\n  }\n\n  @eventOptions({ passive: true })\n  private _visibilityChanged(e: VisibilityChangedEvent) {\n    fireEvent(this, \"hass-logbook-live\", {\n      enable: e.first === 0,\n    });\n  }\n\n  private _renderIndicator(item: LogbookEntry) {\n    const stateObj = this.hass.states[item.entity_id!] as\n      | HassEntity\n      | undefined;\n    const computedStyles = getComputedStyle(this);\n\n    const color =\n      item.state !== undefined\n        ? computeTimelineColor(item.state, computedStyles, stateObj)\n        : undefined;\n\n    const style = {\n      backgroundColor: color,\n    };\n\n    return html` <div class=\"indicator\" style=${styleMap(style)}></div> `;\n  }\n\n  private _renderMessage(\n    item: LogbookEntry,\n    seenEntityIds: string[],\n    domain?: string,\n    historicStateObj?: HassEntity,\n    noLink?: boolean\n  ) {\n    if (item.entity_id) {\n      if (item.state) {\n        return historicStateObj\n          ? localizeStateMessage(\n              this.hass,\n              this.hass.localize,\n              item.state,\n              historicStateObj,\n              domain!\n            )\n          : item.state;\n      }\n    }\n\n    const itemHasContext = hasContext(item);\n    let message = item.message;\n    if (triggerDomains.includes(domain!) && item.source) {\n      if (itemHasContext) {\n        // These domains include the trigger source in the message\n        // but if we have the context we want to display that instead\n        // as otherwise we display duplicate triggers\n        return \"\";\n      }\n      message = localizeTriggerSource(this.hass.localize, item.source);\n    }\n    return message\n      ? this._formatMessageWithPossibleEntity(\n          itemHasContext\n            ? stripEntityId(message, item.context_entity_id)\n            : message,\n          seenEntityIds,\n          undefined,\n          noLink\n        )\n      : \"\";\n  }\n\n  private _renderUser(item: LogbookEntry) {\n    const item_username =\n      item.context_user_id && this.userIdToName[item.context_user_id];\n    if (item_username) {\n      return `- ${item_username}`;\n    }\n    return \"\";\n  }\n\n  private _renderUnseenContextSourceEntity(\n    item: LogbookEntry,\n    seenEntityIds: string[],\n    noLink: boolean\n  ) {\n    if (\n      !item.context_entity_id ||\n      seenEntityIds.includes(item.context_entity_id!)\n    ) {\n      return \"\";\n    }\n    // We don't know what caused this entity\n    // to be included since its an integration\n    // described event.\n    return html` (${this._renderEntity(\n      item.context_entity_id,\n      item.context_entity_id_name,\n      noLink\n    )})`;\n  }\n\n  private _renderContextMessage(\n    item: LogbookEntry,\n    seenEntityIds: string[],\n    noLink: boolean\n  ) {\n    // State change\n    if (item.context_state) {\n      const historicStateObj =\n        item.context_entity_id && item.context_entity_id in this.hass.states\n          ? createHistoricState(\n              this.hass.states[item.context_entity_id],\n              item.context_state\n            )\n          : undefined;\n      return html`${this.hass.localize(\n        \"ui.components.logbook.triggered_by_state_of\"\n      )}\n      ${this._renderEntity(\n        item.context_entity_id,\n        item.context_entity_id_name,\n        noLink\n      )}\n      ${historicStateObj\n        ? localizeStateMessage(\n            this.hass,\n            this.hass.localize,\n            item.context_state,\n            historicStateObj,\n            computeDomain(item.context_entity_id!)\n          )\n        : item.context_state}`;\n    }\n    // Service call\n    if (item.context_event_type === \"call_service\") {\n      return html`${this.hass.localize(\n        \"ui.components.logbook.triggered_by_service\"\n      )}\n      ${item.context_domain}.${item.context_service}`;\n    }\n    if (\n      !item.context_message ||\n      seenEntityIds.includes(item.context_entity_id!)\n    ) {\n      return \"\";\n    }\n    // Automation or script\n    if (\n      item.context_event_type === \"automation_triggered\" ||\n      item.context_event_type === \"script_started\"\n    ) {\n      // context_source is available in 2022.6 and later\n      const triggerMsg = item.context_source\n        ? item.context_source\n        : item.context_message.replace(\"triggered by \", \"\");\n      const contextTriggerSource = localizeTriggerSource(\n        this.hass.localize,\n        triggerMsg\n      );\n      return html`${this.hass.localize(\n        item.context_event_type === \"automation_triggered\"\n          ? \"ui.components.logbook.triggered_by_automation\"\n          : \"ui.components.logbook.triggered_by_script\"\n      )}\n      ${this._renderEntity(\n        item.context_entity_id,\n        item.context_entity_id_name,\n        noLink\n      )}\n      ${item.context_message\n        ? this._formatMessageWithPossibleEntity(\n            contextTriggerSource,\n            seenEntityIds,\n            undefined,\n            noLink\n          )\n        : \"\"}`;\n    }\n    // Generic externally described logbook platform\n    // These are not localizable\n    return html` ${this.hass.localize(\"ui.components.logbook.triggered_by\")}\n    ${item.context_name}\n    ${this._formatMessageWithPossibleEntity(\n      item.context_message,\n      seenEntityIds,\n      item.context_entity_id,\n      noLink\n    )}\n    ${this._renderUnseenContextSourceEntity(item, seenEntityIds, noLink)}`;\n  }\n\n  private _renderEntity(\n    entityId: string | undefined,\n    entityName: string | undefined,\n    noLink?: boolean\n  ) {\n    const hasState = entityId && entityId in this.hass.states;\n    const displayName =\n      entityName ||\n      (hasState\n        ? this.hass.states[entityId].attributes.friendly_name || entityId\n        : entityId);\n    if (!hasState) {\n      return displayName;\n    }\n    return noLink\n      ? displayName\n      : html`<button\n          class=\"link\"\n          @click=${this._entityClicked}\n          .entityId=${entityId}\n        >\n          ${displayName}\n        </button>`;\n  }\n\n  private _formatMessageWithPossibleEntity(\n    message: string,\n    seenEntities: string[],\n    possibleEntity?: string,\n    noLink?: boolean\n  ) {\n    //\n    // As we are looking at a log(book), we are doing entity_id\n    // \"highlighting\"/\"colorizing\". The goal is to make it easy for\n    // the user to access the entity that caused the event.\n    //\n    // If there is an entity_id in the message that is also in the\n    // state machine, we search the message for the entity_id and\n    // replace it with _renderEntity\n    //\n    if (message.indexOf(\".\") !== -1) {\n      const messageParts = message.split(\" \");\n      for (let i = 0, size = messageParts.length; i < size; i++) {\n        if (messageParts[i] in this.hass.states) {\n          const entityId = messageParts[i];\n          if (seenEntities.includes(entityId)) {\n            return \"\";\n          }\n          seenEntities.push(entityId);\n          const messageEnd = messageParts.splice(i);\n          messageEnd.shift(); // remove the entity\n          return html`${messageParts.join(\" \")}\n          ${this._renderEntity(\n            entityId,\n            this.hass.states[entityId].attributes.friendly_name,\n            noLink\n          )}\n          ${messageEnd.join(\" \")}`;\n        }\n      }\n    }\n    //\n    // When we have a message has a specific entity_id attached to\n    // it, and the entity_id is not in the message, we look\n    // for the friendly name of the entity and replace that with\n    // _renderEntity if its there so the user can quickly get to\n    // that entity.\n    //\n    if (possibleEntity && possibleEntity in this.hass.states) {\n      const possibleEntityName =\n        this.hass.states[possibleEntity].attributes.friendly_name;\n      if (possibleEntityName && message.endsWith(possibleEntityName)) {\n        if (seenEntities.includes(possibleEntity)) {\n          return \"\";\n        }\n        seenEntities.push(possibleEntity);\n        message = message.substring(\n          0,\n          message.length - possibleEntityName.length\n        );\n        return html`${message}\n        ${this._renderEntity(possibleEntity, possibleEntityName, noLink)}`;\n      }\n    }\n    return message;\n  }\n\n  private _entityClicked(ev: Event) {\n    const entityId = (ev.currentTarget as any).entityId;\n    if (!entityId) {\n      return;\n    }\n\n    ev.preventDefault();\n    ev.stopPropagation();\n    fireEvent(this, \"hass-more-info\", {\n      entityId: entityId,\n    });\n  }\n\n  _handleClick(ev) {\n    if (!ev.currentTarget.traceLink) {\n      return;\n    }\n    navigate(ev.currentTarget.traceLink);\n    fireEvent(this, \"closed\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      haStyleScrollbar,\n      buttonLinkStyle,\n      css`\n        :host([virtualize]) {\n          display: block;\n          height: 100%;\n        }\n\n        .entry-container {\n          width: 100%;\n        }\n\n        .entry {\n          position: relative;\n          display: flex;\n          width: 100%;\n          line-height: 2em;\n          padding: 8px 16px;\n          box-sizing: border-box;\n          border-top: 1px solid var(--divider-color);\n          justify-content: space-between;\n          align-items: center;\n        }\n\n        .indicator {\n          background-color: var(--disabled-color);\n          height: 8px;\n          width: 8px;\n          border-radius: 4px;\n          flex-shrink: 0;\n          margin-right: 12px;\n          margin-inline-start: initial;\n          margin-inline-end: 12px;\n          direction: var(--direction);\n        }\n\n        ha-icon-next {\n          color: var(--secondary-text-color);\n        }\n\n        .clickable {\n          cursor: pointer;\n        }\n\n        :not(.clickable) .entry.no-entity,\n        :not(.clickable) .no-name .entry {\n          cursor: default;\n        }\n\n        .entry:hover {\n          background-color: rgba(var(--rgb-primary-text-color), 0.04);\n        }\n\n        .narrow:not(.no-icon) .time {\n          margin-left: 32px;\n          margin-inline-start: 32px;\n          margin-inline-end: initial;\n          direction: var(--direction);\n        }\n\n        .message-relative_time {\n          display: flex;\n          flex-direction: column;\n        }\n\n        .secondary {\n          font-size: 12px;\n          line-height: 1.7;\n        }\n\n        .secondary a {\n          color: var(--secondary-text-color);\n        }\n\n        .date {\n          margin: 8px 0;\n          padding: 0 16px;\n        }\n\n        .icon-message {\n          display: flex;\n          align-items: center;\n        }\n\n        .no-entries {\n          text-align: center;\n          color: var(--secondary-text-color);\n        }\n\n        state-badge {\n          margin-right: 16px;\n          margin-inline-start: initial;\n          flex-shrink: 0;\n          color: var(--state-icon-color);\n          margin-inline-end: 16px;\n          direction: var(--direction);\n        }\n\n        .message {\n          color: var(--primary-text-color);\n        }\n\n        .no-name .message:first-letter {\n          text-transform: capitalize;\n        }\n\n        a {\n          color: var(--primary-color);\n          text-decoration: none;\n        }\n\n        button.link {\n          color: var(--paper-item-icon-color);\n          text-decoration: none;\n        }\n\n        .container {\n          max-height: var(--logbook-max-height);\n        }\n\n        .container,\n        lit-virtualizer {\n          height: 100%;\n        }\n\n        lit-virtualizer {\n          contain: size layout !important;\n        }\n\n        .narrow .entry {\n          line-height: 1.5;\n        }\n\n        .narrow .icon-message state-badge {\n          margin-left: 0;\n          margin-inline-start: 0;\n          margin-inline-end: 8px;\n          margin-right: 8px;\n          direction: var(--direction);\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-logbook-renderer\": HaLogbookRenderer;\n  }\n}\n","import { css, html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport { ensureArray } from \"../../common/array/ensure-array\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { throttle } from \"../../common/util/throttle\";\nimport \"../../components/ha-circular-progress\";\nimport {\n  clearLogbookCache,\n  LogbookEntry,\n  LogbookStreamMessage,\n  subscribeLogbook,\n} from \"../../data/logbook\";\nimport { loadTraceContexts, TraceContexts } from \"../../data/trace\";\nimport { fetchUsers } from \"../../data/user\";\nimport { HomeAssistant } from \"../../types\";\nimport \"./ha-logbook-renderer\";\n\ninterface LogbookTimePeriod {\n  now: Date;\n  startTime: Date;\n  endTime: Date;\n  purgeBeforePythonTime: number | undefined;\n}\n\nconst findStartOfRecentTime = (now: Date, recentTime: number) =>\n  new Date(now.getTime() - recentTime * 1000).getTime() / 1000;\n\nconst idsChanged = (oldIds?: string[], newIds?: string[]) => {\n  if (oldIds === undefined && newIds === undefined) {\n    return false;\n  }\n  return (\n    !oldIds ||\n    !newIds ||\n    oldIds.length !== newIds.length ||\n    !oldIds.every((val) => newIds.includes(val))\n  );\n};\n\n@customElement(\"ha-logbook\")\nexport class HaLogbook extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public time!:\n    | { range: [Date, Date] }\n    | {\n        // Seconds\n        recent: number;\n      };\n\n  @property() public entityIds?: string[];\n\n  @property() public deviceIds?: string[];\n\n  @property({ type: Boolean, attribute: \"narrow\" })\n  public narrow = false;\n\n  @property({ type: Boolean, attribute: \"virtualize\", reflect: true })\n  public virtualize = false;\n\n  @property({ type: Boolean, attribute: \"no-icon\" })\n  public noIcon = false;\n\n  @property({ type: Boolean, attribute: \"no-name\" })\n  public noName = false;\n\n  @property({ type: Boolean, attribute: \"show-indicator\" })\n  public showIndicator = false;\n\n  @property({ type: Boolean, attribute: \"relative-time\" })\n  public relativeTime = false;\n\n  @property({ type: Boolean }) public showMoreLink = true;\n\n  @state() private _logbookEntries?: LogbookEntry[];\n\n  @state() private _traceContexts: TraceContexts = {};\n\n  @state() private _userIdToName = {};\n\n  @state() private _error?: string;\n\n  private _subscribed?: Promise<(() => Promise<void>) | void>;\n\n  private _liveUpdatesEnabled = true;\n\n  private _pendingStreamMessages: LogbookStreamMessage[] = [];\n\n  private _throttleGetLogbookEntries = throttle(\n    () => this._getLogBookData(),\n    1000\n  );\n\n  protected render(): TemplateResult {\n    if (!isComponentLoaded(this.hass, \"logbook\")) {\n      return html``;\n    }\n\n    if (this._error) {\n      return html`<div class=\"no-entries\">\n        ${`${this.hass.localize(\"ui.components.logbook.retrieval_error\")}: ${\n          this._error\n        }`}\n      </div>`;\n    }\n\n    if (this._logbookEntries === undefined) {\n      return html`\n        <div class=\"progress-wrapper\">\n          <ha-circular-progress\n            active\n            alt=${this.hass.localize(\"ui.common.loading\")}\n          ></ha-circular-progress>\n        </div>\n      `;\n    }\n\n    if (this._logbookEntries.length === 0) {\n      return html`<div class=\"no-entries\">\n        ${this.hass.localize(\"ui.components.logbook.entries_not_found\")}\n      </div>`;\n    }\n\n    return html`\n      <ha-logbook-renderer\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        .virtualize=${this.virtualize}\n        .noIcon=${this.noIcon}\n        .noName=${this.noName}\n        .showIndicator=${this.showIndicator}\n        .relativeTime=${this.relativeTime}\n        .entries=${this._logbookEntries}\n        .traceContexts=${this._traceContexts}\n        .userIdToName=${this._userIdToName}\n        @hass-logbook-live=${this._handleLogbookLive}\n      ></ha-logbook-renderer>\n    `;\n  }\n\n  public async refresh(force = false) {\n    if (!force && (this._subscribed || this._logbookEntries === undefined)) {\n      return;\n    }\n\n    this._unsubscribeSetLoading();\n    this._throttleGetLogbookEntries.cancel();\n    this._updateTraceContexts.cancel();\n    this._updateUsers.cancel();\n\n    if (\"range\" in this.time) {\n      clearLogbookCache(\n        this.time.range[0].toISOString(),\n        this.time.range[1].toISOString()\n      );\n    }\n\n    this._throttleGetLogbookEntries();\n  }\n\n  protected firstUpdated(changedProps: PropertyValues) {\n    super.firstUpdated(changedProps);\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    if (changedProps.size !== 1 || !changedProps.has(\"hass\")) {\n      return true;\n    }\n    // We only respond to hass changes if the translations changed\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    return !oldHass || oldHass.localize !== this.hass.localize;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    let changed = changedProps.has(\"time\");\n\n    for (const key of [\"entityIds\", \"deviceIds\"]) {\n      if (!changedProps.has(key)) {\n        continue;\n      }\n\n      const oldValue = changedProps.get(key) as string[] | undefined;\n      const curValue = this[key] as string[] | undefined;\n\n      // If they make the filter more specific we want\n      // to change the subscription since it will reduce\n      // the overhead on the backend as the event stream\n      // can be a firehose for all state events.\n      if (idsChanged(oldValue, curValue)) {\n        changed = true;\n        break;\n      }\n    }\n\n    if (changed) {\n      this.refresh(true);\n    }\n  }\n\n  private _handleLogbookLive(ev: CustomEvent) {\n    if (ev.detail.enable && !this._liveUpdatesEnabled) {\n      // Process everything we queued up while we were scrolled down\n      this._pendingStreamMessages.forEach((msg) =>\n        this._processStreamMessage(msg)\n      );\n      this._pendingStreamMessages = [];\n    }\n    this._liveUpdatesEnabled = ev.detail.enable;\n  }\n\n  private get _filterAlwaysEmptyResults(): boolean {\n    const entityIds = ensureArray(this.entityIds);\n    const deviceIds = ensureArray(this.deviceIds);\n\n    // If all specified filters are empty lists, we can return an empty list.\n    return (\n      (entityIds || deviceIds) &&\n      (!entityIds || entityIds.length === 0) &&\n      (!deviceIds || deviceIds.length === 0)\n    );\n  }\n\n  private _unsubscribe(): void {\n    if (this._subscribed) {\n      this._subscribed.then((unsub) =>\n        unsub\n          ? unsub().catch(() => {\n              // The backend will cancel the subscription if\n              // we subscribe to entities that will all be\n              // filtered away\n            })\n          : undefined\n      );\n      this._subscribed = undefined;\n    }\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (this.hasUpdated) {\n      this._subscribeLogbookPeriod(this._calculateLogbookPeriod());\n    }\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._unsubscribeSetLoading();\n  }\n\n  /** Unsubscribe because we are unloading\n   * or about to resubscribe.\n   * Setting this._logbookEntries to undefined\n   * will put the page in a loading state.\n   */\n  private _unsubscribeSetLoading() {\n    this._logbookEntries = undefined;\n    this._unsubscribe();\n  }\n\n  /** Unsubscribe because there are no results.\n   * Setting this._logbookEntries to an empty\n   * list will show a no results message.\n   */\n  private _unsubscribeNoResults() {\n    this._logbookEntries = [];\n    this._unsubscribe();\n  }\n\n  private _calculateLogbookPeriod() {\n    const now = new Date();\n    if (\"range\" in this.time) {\n      return <LogbookTimePeriod>{\n        now: now,\n        startTime: this.time.range[0],\n        endTime: this.time.range[1],\n        purgeBeforePythonTime: undefined,\n      };\n    }\n    if (\"recent\" in this.time) {\n      const purgeBeforePythonTime = findStartOfRecentTime(\n        now,\n        this.time.recent\n      );\n      return <LogbookTimePeriod>{\n        now: now,\n        startTime: new Date(purgeBeforePythonTime * 1000),\n        // end streaming one year from now\n        endTime: new Date(now.getTime() + 86400 * 365 * 1000),\n        purgeBeforePythonTime: findStartOfRecentTime(now, this.time.recent),\n      };\n    }\n    throw new Error(\"Unexpected time specified\");\n  }\n\n  private _subscribeLogbookPeriod(logbookPeriod: LogbookTimePeriod) {\n    if (this._subscribed) {\n      return true;\n    }\n    this._subscribed = subscribeLogbook(\n      this.hass,\n      (streamMessage) => {\n        // \"recent\" means start time is a sliding window\n        // so we need to calculate an expireTime to\n        // purge old events\n        if (!this._subscribed) {\n          // Message came in before we had a chance to unload\n          return;\n        }\n        this._processOrQueueStreamMessage(streamMessage);\n      },\n      logbookPeriod.startTime.toISOString(),\n      logbookPeriod.endTime.toISOString(),\n      ensureArray(this.entityIds),\n      ensureArray(this.deviceIds)\n    ).catch((err) => {\n      this._subscribed = undefined;\n      this._error = err;\n    });\n    return true;\n  }\n\n  private async _getLogBookData() {\n    this._error = undefined;\n\n    if (this._filterAlwaysEmptyResults) {\n      this._unsubscribeNoResults();\n      return;\n    }\n\n    const logbookPeriod = this._calculateLogbookPeriod();\n\n    if (logbookPeriod.startTime > logbookPeriod.now) {\n      // Time Travel not yet invented\n      this._unsubscribeNoResults();\n      return;\n    }\n\n    this._updateUsers();\n    if (this.hass.user?.is_admin) {\n      this._updateTraceContexts();\n    }\n\n    this._subscribeLogbookPeriod(logbookPeriod);\n  }\n\n  private _nonExpiredRecords = (purgeBeforePythonTime: number | undefined) =>\n    !this._logbookEntries\n      ? []\n      : purgeBeforePythonTime\n      ? this._logbookEntries.filter(\n          (entry) => entry.when > purgeBeforePythonTime!\n        )\n      : this._logbookEntries;\n\n  private _processOrQueueStreamMessage = (\n    streamMessage: LogbookStreamMessage\n  ) => {\n    if (this._liveUpdatesEnabled) {\n      this._processStreamMessage(streamMessage);\n      return;\n    }\n    this._pendingStreamMessages.push(streamMessage);\n  };\n\n  private _processStreamMessage = (streamMessage: LogbookStreamMessage) => {\n    const purgeBeforePythonTime =\n      \"recent\" in this.time\n        ? findStartOfRecentTime(new Date(), this.time.recent)\n        : undefined;\n    // Put newest ones on top. Reverse works in-place so\n    // make a copy first.\n    const newEntries = [...streamMessage.events].reverse();\n    if (!this._logbookEntries || !this._logbookEntries.length) {\n      this._logbookEntries = newEntries;\n      return;\n    }\n    if (!newEntries.length) {\n      // Empty messages are still sent to\n      // indicate no more historical events\n      return;\n    }\n    const nonExpiredRecords = this._nonExpiredRecords(purgeBeforePythonTime);\n\n    // Entries are sorted in descending order with newest first.\n    if (!nonExpiredRecords.length) {\n      // We have no records left, so we can just replace the list\n      this._logbookEntries = newEntries;\n    } else if (\n      newEntries[newEntries.length - 1].when > // oldest new entry\n      nonExpiredRecords[0].when // newest old entry\n    ) {\n      // The new records are newer than the old records\n      // append the old records to the end of the new records\n      this._logbookEntries = newEntries.concat(nonExpiredRecords);\n    } else if (\n      nonExpiredRecords[nonExpiredRecords.length - 1].when > // oldest old entry\n      newEntries[0].when // newest new entry\n    ) {\n      // The new records are older than the old records\n      // append the new records to the end of the old records\n      this._logbookEntries = nonExpiredRecords.concat(newEntries);\n    } else {\n      // The new records are in the middle of the old records\n      // so we need to re-sort them\n      this._logbookEntries = nonExpiredRecords\n        .concat(newEntries)\n        .sort((a, b) => b.when - a.when);\n    }\n  };\n\n  private _updateTraceContexts = throttle(async () => {\n    this._traceContexts = await loadTraceContexts(this.hass);\n  }, 60000);\n\n  private _updateUsers = throttle(async () => {\n    const userIdToName = {};\n\n    // Start loading users\n    const userProm = this.hass.user?.is_admin && fetchUsers(this.hass);\n\n    // Process persons\n    for (const entity of Object.values(this.hass.states)) {\n      if (\n        entity.attributes.user_id &&\n        computeStateDomain(entity) === \"person\"\n      ) {\n        userIdToName[entity.attributes.user_id] =\n          entity.attributes.friendly_name;\n      }\n    }\n\n    // Process users\n    if (userProm) {\n      const users = await userProm;\n      for (const user of users) {\n        if (!(user.id in userIdToName)) {\n          userIdToName[user.id] = user.name;\n        }\n      }\n    }\n\n    this._userIdToName = userIdToName;\n  }, 60000);\n\n  static get styles() {\n    return [\n      css`\n        :host {\n          display: block;\n        }\n\n        :host([virtualize]) {\n          height: 100%;\n        }\n\n        .no-entries {\n          text-align: center;\n          padding: 16px;\n          color: var(--secondary-text-color);\n        }\n\n        .progress-wrapper {\n          display: flex;\n          justify-content: center;\n          height: 100%;\n          align-items: center;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-logbook\": HaLogbook;\n  }\n}\n"],"names":[],"sourceRoot":""}