{"version":3,"file":"lib_index_js.ac9da941b8bb8e2b38de.js","mappings":";;;;;;;;;;;;;AAAO;AACP;AACA;AACA,kCAAkC,4BAA4B;AAC9D,2CAA2C,4BAA4B;AACvE,oCAAoC,4BAA4B;AAChE,oCAAoC,2BAA2B;AAC/D,CAAC,8BAA8B;;;;;;;;;;;;;;;;;;;;;;ACPyB;AACjB;AACC;AACsB;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAM;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAkB;AAC/C,6BAA6B,0DAAkB;AAC/C,6BAA6B,uDAAe;AAC5C,6BAA6B,uDAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAwB;AAC7C;AACA,SAAS;AACT;AACA,qBAAqB,yEAAiC;AACtD;AACA,SAAS;AACT;AACA;AACA,qCAAqC,gEAAwB;AAC7D;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,qCAAqC,yEAAiC;AACtE;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/L+D;AACQ;AAClB;AACG;AACA;AACgC;AACwC;AACxF;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6DAAqB,6BAA6B,6DAAqB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAqB;AACzB,IAAI,6DAAqB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAW;AACnB,QAAQ,iFAAyB;AACjC,QAAQ,yEAAgB;AACxB,QAAQ,kEAAc;AACtB,QAAQ,kEAAgB;AACxB;AACA;AACA;AACA,iCAAiC,oDAAY;AAC7C,qCAAqC,+DAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oDAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8EAA8E,OAAO;AACrF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAe;AACjD,kCAAkC,0DAAkB;AACpD,kCAAkC,0DAAkB;AACpD,kCAAkC,uDAAe;AACjD,kCAAkC,0DAAkB;AACpD,kCAAkC,0DAAkB;AACpD;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;;;AChIkD;AACxE;AACA,eAAe,SAAS;AACxB;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C,kCAAkC,aAAa;AAC/C,uBAAuB,MAAM,GAAG,UAAU,GAAG,WAAW,GAAG,UAAU;AACrE;AACO;AACP;AACA;AACA,qBAAqB,gBAAgB;AACrC,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4BAA4B,qBAAqB,EAAE,SAAS;AAC5D;AACA;AACA;AACA,SAAS;AACT;AACA,4BAA4B,qBAAqB,EAAE,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACO;AACP,eAAe,kFAA0B;AACzC;AACA,oBAAoB,MAAM,EAAE,qBAAqB,EAAE,SAAS;AAC5D;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,eAAe,kFAA0B;AACzC;AACA,oBAAoB,MAAM,EAAE,qBAAqB,EAAE,SAAS;AAC5D;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,eAAe,kFAA0B;AACzC;AACA,oBAAoB,gBAAgB,cAAc,cAAc;AAChE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL,sCAAsC,SAAS;AAC/C;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,KAAK;AACL","sources":["webpack://jupyterlab-sql-editor/./lib/constants.js","webpack://jupyterlab-sql-editor/./lib/formatter.js","webpack://jupyterlab-sql-editor/./lib/index.js","webpack://jupyterlab-sql-editor/./lib/utils.js"],"sourcesContent":["export var Constants;\n(function (Constants) {\n    Constants.SHORT_PLUGIN_NAME = 'jupyterlab-sql-editor';\n    Constants.FORMAT_COMMAND = `${Constants.SHORT_PLUGIN_NAME}:format_cell`;\n    Constants.FORMAT_COMMAND_DOCUMENT = `${Constants.SHORT_PLUGIN_NAME}:format_document`;\n    Constants.LONG_PLUGIN_NAME = `${Constants.SHORT_PLUGIN_NAME}`;\n    Constants.SETTINGS_SECTION = `${Constants.LONG_PLUGIN_NAME}:plugin`;\n})(Constants || (Constants = {}));\n","import { showErrorMessage } from '@jupyterlab/apputils';\nimport { format } from 'sql-formatter';\nimport { Constants } from './constants';\nimport { cellMagicExtractor, markerExtractor } from './utils';\nexport class SqlFormatter {\n    constructor(formatTabWidth, formatUseTabs, formatKeywordCase) {\n        this.formatTabWidth = formatTabWidth;\n        this.formatUseTabs = formatUseTabs;\n        this.formatKeywordCase = formatKeywordCase;\n    }\n    format(text) {\n        const formatted = format(text || '', {\n            language: 'spark',\n            tabWidth: this.formatTabWidth,\n            useTabs: this.formatUseTabs,\n            keywordCase: this.formatKeywordCase,\n            linesBetweenQueries: 2 // Defaults to 1\n        });\n        return formatted;\n    }\n}\nclass JupyterlabNotebookCodeFormatter {\n    constructor(notebookTracker, codeMirror, sqlFormatter) {\n        this.working = false;\n        this.notebookTracker = notebookTracker;\n        this.extractors = [];\n        this.extractors.push(cellMagicExtractor('sparksql'));\n        this.extractors.push(cellMagicExtractor('trino'));\n        this.extractors.push(markerExtractor('sparksql'));\n        this.extractors.push(markerExtractor('trino'));\n        this.codeMirror = codeMirror;\n        this.sqlFormatter = sqlFormatter;\n    }\n    setFormatter(sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n    }\n    async formatAction() {\n        return this.formatCells(true);\n    }\n    async formatSelectedCodeCells(notebook) {\n        return this.formatCells(true, notebook);\n    }\n    getCodeCells(selectedOnly = true, notebook) {\n        if (!this.notebookTracker.currentWidget) {\n            return [];\n        }\n        const codeCells = [];\n        notebook = notebook || this.notebookTracker.currentWidget.content;\n        notebook.widgets.forEach((cell) => {\n            if (cell.model.type === 'code') {\n                if (!selectedOnly || (notebook === null || notebook === void 0 ? void 0 : notebook.isSelectedOrActive(cell))) {\n                    codeCells.push(cell);\n                }\n            }\n        });\n        return codeCells;\n    }\n    tryReplacing(cellText, extractor) {\n        const extracted = extractor.extract_foreign_code(cellText);\n        if (extracted &&\n            extracted.length > 0 &&\n            extracted[0].foreign_code &&\n            extracted[0].range) {\n            const sqlText = extracted[0].foreign_code;\n            const formattedSql = this.sqlFormatter.format(sqlText) + '\\n';\n            const doc = new this.codeMirror.CodeMirror.Doc(cellText, 'sql', 0, '\\n');\n            const startPos = new this.codeMirror.CodeMirror.Pos(extracted[0].range.start.line, extracted[0].range.start.column);\n            const endPos = new this.codeMirror.CodeMirror.Pos(extracted[0].range.end.line, extracted[0].range.end.column);\n            doc.replaceRange(formattedSql, startPos, endPos);\n            return doc.getValue();\n        }\n        return null;\n    }\n    async formatCells(selectedOnly, notebook) {\n        if (this.working || !this.applicable()) {\n            return;\n        }\n        try {\n            this.working = true;\n            const selectedCells = this.getCodeCells(selectedOnly, notebook);\n            if (selectedCells.length > 0) {\n                const currentTexts = selectedCells.map(cell => cell.model.value.text);\n                const formattedTexts = currentTexts.map(cellText => {\n                    const formatted = this.extractors\n                        .map(extractor => this.tryReplacing(cellText, extractor))\n                        .find(formatted => formatted);\n                    return formatted || '';\n                });\n                for (let i = 0; i < selectedCells.length; ++i) {\n                    const cell = selectedCells[i];\n                    const currentText = currentTexts[i];\n                    const formattedText = formattedTexts[i];\n                    if (cell.model.value.text === currentText) {\n                        cell.model.value.text = formattedText;\n                    }\n                }\n            }\n        }\n        catch (error) {\n            await showErrorMessage('Jupyterlab Code Formatter Error', error);\n        }\n        finally {\n            this.working = false;\n        }\n    }\n    applicable() {\n        const selectedCells = this.getCodeCells();\n        if (selectedCells.length > 0) {\n            const currentTexts = selectedCells.map(cell => cell.model.value.text);\n            let numSqlCells = 0;\n            currentTexts.forEach(cellText => {\n                const found = this.extractors.find(extractor => extractor.has_foreign_code(cellText));\n                if (found) {\n                    numSqlCells++;\n                }\n            });\n            // eslint-disable-next-line eqeqeq\n            return numSqlCells == selectedCells.length;\n        }\n        return false;\n    }\n}\nclass JupyterlabFileEditorCodeFormatter {\n    constructor(editorTracker, sqlFormatter) {\n        this.working = false;\n        this.editorTracker = editorTracker;\n        this.sqlFormatter = sqlFormatter;\n    }\n    setFormatter(sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n    }\n    formatAction() {\n        if (this.working) {\n            return;\n        }\n        const editorWidget = this.editorTracker.currentWidget;\n        if (editorWidget) {\n            try {\n                this.working = true;\n                const editor = editorWidget.content.editor;\n                const code = editor === null || editor === void 0 ? void 0 : editor.model.value.text;\n                const formatted = this.sqlFormatter.format(code);\n                editorWidget.content.editor.model.value.text = formatted;\n            }\n            finally {\n                this.working = false;\n            }\n        }\n    }\n}\nexport class JupyterLabCodeFormatter {\n    constructor(app, tracker, editorTracker, codeMirror, sqlFormatter) {\n        this.app = app;\n        this.tracker = tracker;\n        this.editorTracker = editorTracker;\n        this.notebookCodeFormatter = new JupyterlabNotebookCodeFormatter(this.tracker, codeMirror, sqlFormatter);\n        this.fileEditorCodeFormatter = new JupyterlabFileEditorCodeFormatter(this.editorTracker, sqlFormatter);\n        this.setupCommands();\n        this.setupContextMenu();\n    }\n    setFormatter(sqlFormatter) {\n        this.notebookCodeFormatter.setFormatter(sqlFormatter);\n        this.fileEditorCodeFormatter.setFormatter(sqlFormatter);\n    }\n    setupContextMenu() {\n        this.app.contextMenu.addItem({\n            command: Constants.FORMAT_COMMAND,\n            selector: '.jp-CodeCell'\n        });\n        this.app.contextMenu.addItem({\n            command: Constants.FORMAT_COMMAND_DOCUMENT,\n            selector: '.jp-FileEditor'\n        });\n    }\n    setupCommands() {\n        this.app.commands.addCommand(Constants.FORMAT_COMMAND, {\n            execute: async () => {\n                await this.notebookCodeFormatter.formatSelectedCodeCells();\n            },\n            isVisible: () => {\n                return this.notebookCodeFormatter.applicable();\n            },\n            label: 'Format Sql Cell'\n        });\n        this.app.commands.addCommand(Constants.FORMAT_COMMAND_DOCUMENT, {\n            execute: async () => {\n                await this.fileEditorCodeFormatter.formatAction();\n            },\n            label: 'Format Sql Document'\n        });\n    }\n}\n","import { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { ILSPCodeExtractorsManager } from '@krassowski/jupyterlab-lsp';\nimport { ICodeMirror } from '@jupyterlab/codemirror';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { IEditorTracker } from '@jupyterlab/fileeditor';\nimport { JupyterLabCodeFormatter as SqlCodeFormatter, SqlFormatter } from './formatter';\nimport { cellMagicExtractor, markerExtractor, lineMagicExtractor, sqlCodeMirrorModesFor, registerCodeMirrorFor } from './utils';\nimport { Constants } from './constants';\n/*\nResults in\n\nLINE_MAGIC_EXTRACT\n(?:^|\\n)%sparksql(?: |-c|--cache|-e|--eager|-[a-z] [0-9a-zA-Z/._]+|--[a-zA-Z]+ [0-9a-zA-Z/._]+)*([^\\n]*)\n\nCELL_MAGIC_EXTRACT\n(?:^|\\n)%%sparksql(?: |-c|--cache|-e|--eager|-[a-z] [0-9a-zA-Z/._]+|--[a-zA-Z]+ [0-9a-zA-Z/._]+)*\\n([^]*)\n*/\n/**\n * Code taken from https://github.com/jupyterlab/jupyterlab/blob/master/packages/codemirror/src/codemirror-ipython.ts\n * Modified to support embedded sql syntax\n */\nfunction codeMirrorWithSqlSyntaxHighlightSupport(c) {\n    /**\n     * Define an IPython codemirror mode.\n     *\n     * It is a slightly altered Python Mode with a `?` operator.\n     */\n    c.CodeMirror.defineMode('ipython', (config, modeOptions) => {\n        const pythonConf = {};\n        for (const prop in modeOptions) {\n            if (modeOptions.hasOwnProperty(prop)) {\n                pythonConf[prop] = modeOptions[prop];\n            }\n        }\n        pythonConf.name = 'python';\n        pythonConf.singleOperators = new RegExp('^[\\\\+\\\\-\\\\*/%&|@\\\\^~<>!\\\\?]');\n        pythonConf.identifiers = new RegExp('^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*');\n        //return c.CodeMirror.getMode(config, pythonConf);\n        // Instead of returning this mode we multiplex it with SQL\n        const pythonMode = c.CodeMirror.getMode(config, pythonConf);\n        // get a mode for SQL\n        const sqlMode = c.CodeMirror.getMode(config, 'sql');\n        // multiplex python with SQL and return it\n        const multiplexedModes = sqlCodeMirrorModesFor('sparksql', sqlMode).concat(sqlCodeMirrorModesFor('trino', sqlMode));\n        return c.CodeMirror.multiplexingMode(pythonMode, ...multiplexedModes);\n    }\n    // Original code has a third argument. Not sure why we don't..\n    // https://github.com/jupyterlab/jupyterlab/blob/master/packages/codemirror/src/codemirror-ipython.ts\n    // ,\n    // 'python'\n    );\n    registerCodeMirrorFor(c, 'sparksql');\n    registerCodeMirrorFor(c, 'trino');\n    // The following is already done by default implementation so not redoing here\n    // c.CodeMirror.defineMIME('text/x-ipython', 'ipython');\n    // c.CodeMirror.modeInfo.push({\n    //   ext: [],\n    //   mime: 'text/x-ipython',\n    //   mode: 'ipython',\n    //   name: 'ipython'\n    // });\n}\n/**\n * Initialization data for the jupyterlab_jc extension.\n */\nconst plugin = {\n    id: 'jupyterlab-sql-editor:plugin',\n    autoStart: true,\n    optional: [],\n    requires: [\n        ICodeMirror,\n        ILSPCodeExtractorsManager,\n        ISettingRegistry,\n        IEditorTracker,\n        INotebookTracker\n    ],\n    activate: (app, codeMirror, lspExtractorsMgr, settingRegistry, editorTracker, tracker) => {\n        console.log('JupyterLab extension jupyterlab-sql-editor is activated!');\n        const sqlFormatter = new SqlFormatter(4, false, 'upper');\n        const sqlCodeFormatter = new SqlCodeFormatter(app, tracker, editorTracker, codeMirror, sqlFormatter);\n        console.log('jupyterlab-sql-editor SQL code formatter registered');\n        /**\n         * Load the settings for this extension\n         *\n         * @param setting Extension settings\n         */\n        function loadSetting(settings) {\n            // Read the settings and convert to the correct type\n            const formatTabwidth = settings.get('formatTabWidth').composite;\n            const formatUseTabs = settings.get('formatUseTabs').composite;\n            const formatKeywordCase = settings.get('formatKeywordCase')\n                .composite;\n            const sqlFormatter = new SqlFormatter(formatTabwidth, formatUseTabs, formatKeywordCase);\n            sqlCodeFormatter.setFormatter(sqlFormatter);\n        }\n        // Wait for the application to be restored and\n        // for the settings for this plugin to be loaded\n        Promise.all([\n            app.restored,\n            settingRegistry.load(Constants.SETTINGS_SECTION)\n        ])\n            .then(([, settings]) => {\n            // Read the settings\n            loadSetting(settings);\n            // Listen for your plugin setting changes using Signal\n            settings.changed.connect(loadSetting);\n        })\n            .catch(reason => {\n            console.error(`Something went wrong when reading the settings.\\n${reason}`);\n        });\n        // JupyterLab uses the CodeMirror library to syntax highlight code\n        // within the cells. Register a multiplex CodeMirror capable of\n        // highlightin SQL which is embedded in a IPython magic or within\n        // a python string (delimited by markers)\n        codeMirrorWithSqlSyntaxHighlightSupport(codeMirror);\n        console.log('jupyterlab-sql-editor code mirror for syntax highlighting registered');\n        // JupyterLab-LSP relies on extractors to pull the SQL out of the cell\n        // and into a virtual document which is then passed to the sql-language-server\n        // for code completion evaluation\n        lspExtractorsMgr.register(markerExtractor('sparksql'), 'python');\n        lspExtractorsMgr.register(lineMagicExtractor('sparksql'), 'python');\n        lspExtractorsMgr.register(cellMagicExtractor('sparksql'), 'python');\n        lspExtractorsMgr.register(markerExtractor('trino'), 'python');\n        lspExtractorsMgr.register(lineMagicExtractor('trino'), 'python');\n        lspExtractorsMgr.register(cellMagicExtractor('trino'), 'python');\n        console.log('jupyterlab-sql-editor LSP extractors registered');\n    }\n};\nexport default plugin;\n","import { RegExpForeignCodeExtractor } from '@krassowski/jupyterlab-lsp';\nfunction line_magic(language) {\n    return `%${language}`;\n}\nfunction cell_magic(language) {\n    return `%%${language}`;\n}\nfunction start(language) {\n    return `--start-${language}`;\n}\nfunction end(language) {\n    return `--end-${language}`;\n}\n// sparksql magic accepts options in the long form\n// --dataframe df\n// or in the short form\n// -d df\n// some options do not require any values, they act more as a flag\nconst FLAG_OPTS = [\n    '-c', '--cache',\n    '-e', '--eager',\n    '-s', '--show-nonprinting',\n    '-x', '--raw',\n    '-j', '--jinja',\n    '-b', '--dbt',\n].join('|');\nconst SPACE = ' ';\nconst OPTION_VALUE = `[0-9a-zA-Z/\\._]+`;\nconst SHORT_OPTS = `-[a-z] ${OPTION_VALUE}`;\nconst LONG_OPTS = `--[_a-zA-Z]+ ${OPTION_VALUE}`;\nconst COMMANDS = `(?:${SPACE}|${FLAG_OPTS}|${SHORT_OPTS}|${LONG_OPTS})*`;\nconst BEGIN = `(?:^|\\n)`;\nexport function sqlCodeMirrorModesFor(language, sqlMode) {\n    return [\n        {\n            open: `${start(language)}`,\n            close: `${end(language)}`,\n            // parseDelimiters is set to true which considers\n            // the marker as part of the SQL statement\n            // it is thus syntax highlighted as a comment\n            parseDelimiters: true,\n            mode: sqlMode\n        },\n        {\n            open: RegExp(`${line_magic(language)}${COMMANDS}`),\n            close: '\\n',\n            parseDelimiters: false,\n            mode: sqlMode\n        },\n        {\n            open: RegExp(`${cell_magic(language)}${COMMANDS}`),\n            close: '__A MARKER THAT WILL NEVER BE MATCHED__',\n            parseDelimiters: false,\n            mode: sqlMode\n        }\n    ];\n}\nexport function lineMagicExtractor(language) {\n    return new RegExpForeignCodeExtractor({\n        language: language,\n        pattern: `${BEGIN}${line_magic(language)}${COMMANDS}([^\\n]*)`,\n        foreign_capture_groups: [1],\n        is_standalone: true,\n        file_extension: language\n    });\n}\nexport function cellMagicExtractor(language) {\n    return new RegExpForeignCodeExtractor({\n        language: language,\n        pattern: `${BEGIN}${cell_magic(language)}${COMMANDS}\\n([^]*)`,\n        foreign_capture_groups: [1],\n        is_standalone: true,\n        file_extension: language\n    });\n}\nexport function markerExtractor(language) {\n    return new RegExpForeignCodeExtractor({\n        language: language,\n        pattern: `${start(language)}.*?\\n([^]*?)${end(language)}`,\n        foreign_capture_groups: [1],\n        is_standalone: true,\n        file_extension: language\n    });\n}\n/**\n * Register text editor based on file type.\n * @param c\n * @param language\n */\nexport function registerCodeMirrorFor(c, language) {\n    c.CodeMirror.defineMode(language, (config, modeOptions) => {\n        const mode = c.CodeMirror.getMode(config, 'sql');\n        return mode;\n    });\n    c.CodeMirror.defineMIME(`text/x-${language}`, language);\n    c.CodeMirror.modeInfo.push({\n        ext: [language],\n        mime: `text/x-${language}`,\n        mode: language,\n        name: language\n    });\n}\n"],"names":[],"sourceRoot":""}